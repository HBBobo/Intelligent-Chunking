{
  "doc_id": "EssCS",
  "sentences": [
    "Essentials\nof computing\n[HEADER] systems.",
    "[HEADER] Coleção Educação | Ciências, Engenharia e Tecnologia.",
    "[HEADER] João M. Fernandes.",
    "COORDENAÇÃO EDITORIAL\nManuela Martins\nFOTO CAPA\nIuzvykova Iaroslava/Shutterstock\nPAGINAÇÃO EM LATEX\nJoão M. Fernandes\nEDIÇÃO UMinho Editora\nLOCAL DE EDIÇÃO Braga 2022\nISBN 978-989-8974-60-0\nDOI https://doi.org/10.21814/uminho.ed.33\nAUTOR\nJoão M. Fernandes\nOs conteúdos apresentados (textos e imagens) são da exclusiva responsabilidade dos respetivos autores.",
    "© Autores / Universidade do Minho – Esta obra encontra-se sob a Licença Internacional Creative Commons Atribuição\nCompartilha Igual 4.0.",
    "UNIVERSIDADE DO MINHO\n[HEADER] Coleção Educação I Ciências, Engenharia e Tecnologia.",
    "Essentials\nof computing\n[HEADER] systems.",
    "[HEADER] João M. Fernandes.",
    "[HEADER] Preface.",
    "[HEADER] About the book.",
    "Computers were originally invented to solve all sort of mathematical problems.",
    "Nowadays,\ncomputers do much more than that and are present in all human activities.",
    "In fact, a com-\nputer is a fantastic machine capable of doing the most amazing tasks, if an appropriate\nprogram is provided.",
    "A computer system contains hardware and systems software that work\ntogether to run software applications.",
    "Interestingly, the underlying concepts that support\nthe construction of a computer are relatively stable.",
    "In fact, (almost) all computer systems\nhave a similar organisation, i.e., their hardware and software components are arranged\nin hierarchical layers (or levels) and perform similar functions.",
    "This book was written for\nprogrammers and software engineers who want to comprehend how the components of a\ncomputer work and how they affect the correctness and performance of their programs.",
    "In fact, understanding how a computer works is a fundamental knowledge for software\nengineers to comprehend the principles governing the execution of the programs they de-\nvelop or maintain.",
    "It is also a fundamental knowledge if one wants to optimise the perfor-\nmance of a program, to write a compiler, or to develop an embedded system.",
    "If a program-\nmer knows exactly how the computer hardware operates, she can write efficient programs.",
    "For example, the method used to map main memory to cache can have a huge impact on the\norder by which array elements are accessed.",
    "Therefore, computer scientists and software\nengineers must understand how computer hardware interacts with software.",
    "This is the ob-\njective of this book, which is focused on describing the fundamental aspects of computers,\nby studying their organisation and structure.",
    "1\nThis book was originally written to support the courses on Computing Systems at Depar-\ntamento de Informática, Universidade do Minho.",
    "The initial structure of these courses was\ndefined by Alberto J. Proença, with the idea of allowing students to understand the main\nprinciples that govern the operation of a computer.",
    "This book still follows that idea, but\nwas tuned to focus on the essential elements of computers that software engineers must\nmaster.",
    "Anyway, we hope that instructors from other universities will adopt this book for\ntheir courses.",
    "1",
    "The distinction among these two terms is fuzzy and is out of the scope of this book.",
    "i\nPREFACE\nii\nThis book addresses a very fundamental aspect related to the Computing discipline, so\nit is expected that any university-level student is able to understand its contents without\nmajor problems.",
    "Anyway, the reader is supposed to have a relatively good knowledge about\nhow to program a computer in a high-level programming language, like C.\nThe book is structured in six chapters.",
    "Chapter 1 introduces the different levels which\none can see a computer, representing each level a distinct abstraction of the computer.",
    "This chapter also describes the von Neumann architecture, which is followed by all modern\ncomputers.",
    "Chapters 2 and 3 address cover the different forms of discrete data found in\ncomputers.",
    "Chapter 2 introduces the main concepts and techniques related to the repre-\nsentation of textual information, instructions, images, and audio.",
    "Chapter 3 explains how\nnumbers are represented in computers.",
    "Chapter 4 discusses the details of the IA32 assem-\nbly language and it discusses how high-level programs (written in C) get compiled into\nthis form of machine code.",
    "Chapter 5 presents the main principles of caches, namely the\ndifferent mapping functions and replacement algorithms.",
    "Chapter 6 explores how to make\nprograms run faster via several different types of program optimisation.",
    "Each chapter has\na set of exercises to ensure that students put in practice the concepts presented.",
    "The book\nprovides answers to almost all those exercises to allow students to check their progress.",
    "A\nglossary, which provides brief definitions of all key terms from the chapters, is also included.",
    "[HEADER] About the author.",
    "João Miguel Fernandes is full professor on software engineering at the Dep.",
    "Informatics,\nSchool of Engineering, UMinho.",
    "João holds a 5-year degree in Informatics Engineering (1991), and a master degree in\nInformatics (1994), both from UMinho (Braga, Portugal).",
    "In May 2000, he has completed his\nPh.D. thesis in Informatics/Computer Engineering, from UMinho, with a thesis entitled “An\nobject-oriented methodology for embedded systems development.”",
    "He has been an invited researcher/professor at Universidade do Algarve (Portugal), Uni-\nversity of Bristol (United Kingdom), Aarhus University (Denmark), TUCS (Turku Centre for\nComputer Science, Turku, Finland), Universitatea Tehnică Gheorghe Asachi (Iaşi, Romania),\nUFSC (Universidade Federal de Santa Catarina, Florianópolis, Brazil), ISCTEM (Mozambique),\nand ISTM (Angola).",
    "João is the main author of the book “Requirements in engineering projects” (Springer,\n2016) and co-editor of the book \"Behavioral modeling for embedded systems and tech-\nnologies: Applications for design and implementation\" (IGI Global, 2009).",
    "He is the author of\nmore than 130 scientific publications with peer revision on international conferences, jour-\nnals and chapters of books.",
    "His publications have collected more than 2.000 citations.",
    "He\nis member of the Editorial Review Board of the Journal of Information Technology Research\n(IGI Publishing) and editor of Open Computer Science (De Gruyter/Springer).",
    "Additionally,\nhe has already served as a scientific reviewer for an Addison-Wesley book, for scientific\njournals and for many symposia.",
    "He also regularly serves as a member of the Programme\nCommittees of international conferences and workshops.",
    "iii\nESSENTIALS OF COMPUTING SYSTEMS\nHe has been involved in the organization of various international scientific events, in-\ncluding the 3rd Int.",
    "Conf.",
    "on Application of Concurrency to System Design (ACSD 2003),\nthe 5th IFIP Int.",
    "Conf.",
    "on Distributed and Parallel Embedded Systems (DIPES 2006), the 3rd\nInternational Summer School on Generative and Transformational Techniques in Software\nEngineering (GTTSE 2009), the 31st International Conference on Application and Theory\nof Petri Nets and Other Models of Concurrency (PETRI NETS 2010), the 10th International\nConference on Application of Concurrency to System Design (ACSD 2010), the 6th Interna-\ntional Conference on Software Business (ICSOB 2015), and the Model-based Methodologies\nfor Pervasive and Embedded Software (MOMPES) workshop series.",
    "João conducts his research activities in Software Engineering, with a special interest in\nthe following topics: software modeling, requirements engineering, embedded software,\nsoftware process, bibliometrics.",
    "Within his research and teaching activities, he maintains\nregular collaborations with the industry.",
    "iFlow, a research project developed in cooperation\nwith Bosch Portugal, received the 2016 Annual Logistics Excellence Award (PEL 2016) from\nthe Portuguese Logistics Association (APLOG).",
    "[HEADER] Acknowledgments.",
    "A number of colleagues have read the intermediate versions of the book and provided use-\nful suggestions.",
    "In particular, I would like to thank Alberto Proença, Luís P. Santos, and\nManuel Alves.",
    "I would also like to acknowledge Luís Gomes and João M.P. Cardoso, who\nacted as reviewers and gave useful feedback and many good suggestions, to ensure a qual-\nity textbook.",
    "The publishing team at UMinho Editora has been wonderful to work with and\na special thanks goes to Carla Marques for the constant help and support.",
    "Alberto Simões\nand Bruno Dias helped me in adjusting the L A TEX styles to comply with the formats of the\npublisher.",
    "Lastly, and most importantly, I am deeply indebted to my wife Raquel and our\ntwo children Gonçalo and Constança.",
    "This book would not have been written without their\npatience and encouragement.",
    "[HEADER] Table of Contents.",
    "Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    ".",
    "i\n1\nComputer systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "1\n1.1\nLevels of a computer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    ".",
    "1\n1.2\nOrganization of a computer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    ".",
    "4\n1.2.1\nCentral processing unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    ".",
    "5\n1.2.2\nMain memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    ".",
    "7\n1.2.3\nSecondary memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    ".",
    "8\n1.2.4\nI/O devices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    ".",
    "9\n1.3\nInstruction-level parallelism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "10\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "13\n2\nRepresentation of information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "15\n2.1\nDigital abstraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "15\n2.2\nBits, bytes and words . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "16\n2.3\nTextual information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "18\n2.4\nMachine-level instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "20\n2.5\nImages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "21\n2.6\nAudio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "22\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "23\n3\nRepresentation of numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "25\n3.1\nPositional numeral systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "25\n3.2\nOctal and hexadecimal numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "27\n3.3\nConversions between different bases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "29\n3.4\nNegative numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "30\n3.4.1\nSign-magnitude . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "31\n3.4.2\nOne’s-complement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "31\n3.4.3\nTwo’s-complement .",
    ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    ".",
    "32\n3.4.4\nExcess representations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "33\n3.5\nTwo’s-complement addition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "34\n3.6\nFloating-point numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "36\nv\nTABLE OF CONTENTS\nvi\n3.7\nBinary codes for decimal numbers .",
    ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    ".",
    "41\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "42\n4\nIA32 instruction-set architecture . .",
    ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    ".",
    "47\n4.1\nCompilation of C code to assembly code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "47\n4.2\nIA32 assembly language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "49\n4.2.1\nRegisters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "50\n4.2.2\nData types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "51\n4.2.3\nOperands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "51\n4.2.4\nData movement instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "52\n4.2.5\nArithmetic and logical instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "55\n4.2.6\nControl instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "59\n4.2.7\nProcedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "63\n4.2.8\nData structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "68\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "71\n5\nCache memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "75\n5.1\nMain principles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "75\n5.2\nMapping function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "78\n5.3\nReplacement algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "82\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "82\n6\nCode optimisations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "85\n6.1\nMain principles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "85\n6.2\nLimitations of the compilers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "86\n6.3\nMachine-independent optimisations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "88\n6.3.1\nCode motion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "89\n6.3.2\nElimination of unnecessary accesses to memory . . . . . . . . . . . . . . . . . . . .",
    "90\n6.3.3\nLoop unrolling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "91\n6.3.4\nReduction of the number of procedure calls . . . . . . . . . . . . . . . . . . . . . . . .",
    "93\n6.4\nMachine-dependent optimisations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "93\n6.5\nCache-oriented optimisations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "95\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "95\nSolutions to exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "99\nGlossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "101\nReferences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "111\nIndex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "113\n\nChapter 1\n[HEADER] Computer systems.",
    "Abstract This chapter introduces the different levels at which one can see a computer.",
    "Each\nlevel represents a distinct abstraction of the computer.",
    "This division in layers permits those\nthat work at a given level to be unaware of what happens in the other levels.",
    "This per-\nspective allows unnecessary details to be omitted, which reduces complexity.",
    "This chapter\nalso describe the von Neumann architecture, which is followed by all modern computers.",
    "It includes a CPU, the main memory, and some input/output devices.",
    "[HEADER] 1.1 Levels of a computer.",
    "A computer is a programmable device that can automatically execute a sequence of in-\nstructions on data once programmed for the task.",
    "It can store, retrieve, and process data\naccording to the instructions.",
    "The sequence of instructions that describe the task to be\nperformed is the program .",
    "It is relevant here to distinguish a computer from a calculator.",
    "A device is considered as\na computer if it has both of the following characteristics, and is a calculator if it lacks either\nor both ( Fenwick , 2015 , pp.",
    "12–13):\n• Data-dependent instruction sequence .",
    "A computer must include conditional branch con-\nstructors (like IF-THEN-ELSE , SWITCH , and DO-WHILE ), whose execution depends on\nvalues that can only be calculated during the program execution (i.e., values that are not\nknown while programming).",
    "• Data-dependent data selection .",
    "A computer must be able to use data to determine the\nactual data to be used in calculations.",
    "This mechanism is used, for example, when ac-\ncessing arrays and other types of structured variables.",
    "The electronic circuits of each computer are able to directly execute a limited set of sim-\nple instructions, into which all its programs must be converted before they can be executed.",
    "These simple instructions are operations like:\n• add two numbers;\n• test if a number is equal to zero;\n1\nCHAPTER 1.",
    "COMPUTER SYSTEMS\n2\n• copy a piece of data from one part to another;\n• decide what instruction to execute next based on the evaluation of some logical condi-\ntion.",
    "These primitive instructions constitute a language, called a machine language , that pro-\ngrammers can use to operate the computer.",
    "The engineers that design a computer must\ndecide what instructions to include in its machine language.",
    "Programming with machine\nlanguages is usually difficult, error-prone, and tedious for people, because they tend to be\nsimple and cryptic.",
    "The machine language exists mainly to be executed by the computer\nand not necessarily to be understood by humans.",
    "Even a simple program may require many\ninstructions, which make the program long and consequently hard to master.",
    "Fortunately,\nnew languages can be constructed on top of the machine language to rise the abstraction\nlevel.",
    "This hierarchical approach is recursive, so computer systems can be designed in an\norganised, structured, and layered way.",
    "In general, a computer can be seen as a set of layers\nor levels, as shown in Fig. 1.1 .",
    "Level 0\nLevel 1\nLevel 2\nLevel 3\nLevel 4\nLevel 5\nLevel 6\nuser\nproblem-oriented language\nassembly language\noperating system machine\ninstruction set architecture (ISA)\nmicroarchitecture\ndigital logic\ntranslation (compiler)\ntranslation (assembler)\npartial interpretation (operating system)\ndirect execution or\ninterpretation (microprogram)\nhardware\nFig.",
    "1.1 A seven-level computer.",
    "The support method for each level and the supporting program is indicated\nbelow it.",
    "Level 6, the user level, is what everyone who interacts with computers is familiar with.",
    "This level contains software applications, like text editors, web browsers, graphics pro-\ngrams, and games.",
    "The user at this level sees software applications that he can select to\nrun for specific purposes.",
    "He can open a word editor to write a letter, a web browser to ac-\ncess a given website, or a game to have fun.",
    "Fortunately, the user can manipulate all these\napplications at this level, without having any idea on how the lower levels work.",
    "Level 5, the problem-oriented language level, consists of languages, like C, C++, Java,\nPerl, Python, and PHP, which are appropriate to develop software applications.",
    "Such lan-\nguages are called high-level languages.",
    "Programs written in these languages are generally\n3\nESSENTIALS OF COMPUTING SYSTEMS\ntranslated to levels 4 or 3 by translators, known as compilers, or interpreted.",
    "For example,\nJava programs are usually first translated to an ISA-like language, called Java byte code,\nwhich is later interpreted.",
    "In some cases, level 5 consists of an interpreter for a specific\napplication domain.",
    "This level provides data and operations for solving problems in this\ndomain, in terms that people familiar with the domain easily understand.",
    "Level 4, the assembly language level, is really a symbolic form for one of the underlying\nlanguages.",
    "This level provides a method for humans to write programs for levels 3 and 2 in\na form that is not as unpleasant as the virtual machine languages themselves.",
    "Programs in\nassembly language are first translated to level 3 or 2 language and then interpreted by the\nappropriate virtual or actual machine.",
    "The program that performs the translation is called\nan assembler .",
    "Level 3 is usually a hybrid level.",
    "Most of the instructions in its language are also in level 2.",
    "This is totally admissible as an instruction at one level can also be present at other levels\nas well.",
    "Additionally, there is a set of new instructions, a different memory organisation,\nthe ability to run two or more programs concurrently, and other features.",
    "The new facilities\nadded at level 3 are carried out by an interpreter running at level 2, which is usually called\nas an operating system .",
    "The level 3 instructions that are identical to those on level 2 are\nexecuted directly by the microprogram (or hardwired control), not by the operating system.",
    "In other words, some of the level 3 instructions are interpreted by the operating system and\nsome are interpreted directly by the microprogram.",
    "This justifies why this level is classified\nas hybrid.",
    "Level 2 is the ISA (instruction set architecture) level.",
    "Every computer is accompanied by an\ninstruction set manual that describes a strictly numerical language, the so-called machine\nlanguage.",
    "A program at this level is machine code, which means that its instructions can\nbe carried out interpretively by the microprogram or the hardware execution circuits.",
    "It is\nthe lowest level representation of a program.",
    "Level 1 is the microarchitecture level, where one sees a relatively small collection of\nregisters, which forms a local memory, and an ALU (arithmetic logic unit), which can execute\nsimple arithmetic operations.",
    "The registers and the ALU are interconnected to form a data\npath, through which the data flow.",
    "The basic operation of the data path consists of selecting\none or two registers, having the ALU operate on them (e.g., adding them together), and\nstoring the result back in some register.",
    "The operation of the data path is usually controlled by a program called a microprogram .",
    "On machines with software control of the data path, the microprogram is an interpreter for\nthe level 2 instructions.",
    "It fetches, examines, and executes instructions one after the other,\nusing the data path to do so.",
    "For example, a SUB instruction is fetched from memory, its\noperands located and transferred to the registers, the subtraction computed by the ALU,\nand finally the result transferred to the destination.",
    "On a machine with hardwired control\nof the data path, similar steps are taken, but without an explicit stored program to control\nthe interpretation of the level 2 instructions.",
    "Finally, level 0, the digital logic level, represents the computer hardware.",
    "Its circuits\nexecute the machine-language programs of level 1.",
    "Level 0 is composed of logic gates and\nwires.",
    "A gate is built from analog components, like transistors.",
    "A gate can be viewed as a\ndigital device with a set of inputs that outputs some simple function, like logical AND or\nOR, of these inputs.",
    "This level also includes flip-flops, which are 1-bit memories that can\nCHAPTER 1.",
    "COMPUTER SYSTEMS\n4\nbe used to store a bit (either a ‘0’ or a ‘1’).",
    "A register can be assembled with, for example,\n32 1-bit memories, which can be used to hold a 32-bit number.",
    "A fundamental frontier exists between levels 4 and 3.",
    "The lowest three levels are in-\ntended primarily for running the interpreters and translators needed to support the highest\nlevels.",
    "These interpreters/translators are developed by systems programmers, who are spe-\ncialised in constructing new virtual machines.",
    "Levels 4 and above are intended for the appli-\ncations programmer with a given problem to solve in a specific domain.",
    "Another change that\noccurs at level 4 is the method by which the higher levels are supported.",
    "Levels 2 and 3 are\nalways interpreted.",
    "Levels 4, 5, and above are usually supported by translation/compilation.",
    "Another difference between levels 1 to 3 and levels 4, 5, and higher is the nature of the\nlanguage provided.",
    "The machine languages of levels 1, 2, and 3 are numeric.",
    "Programs in\nthese levels consist of long series of numbers (bits), which are appropriate for machines, but\nvery hard for humans.",
    "At level 4 and above, the languages contain words and mnemonics\nthat humans are able to easily understand.",
    "To summarise, computers are designed as a series of levels, each one built on its prede-\ncessors.",
    "Each level represents a distinct abstraction of the computer, with different concepts,\nobjects and operations.",
    "This division in layers is very convenient as it permits those that\nwork with the computer at a given level to be unaware, if they wish, of what happens in\nthe other levels.",
    "For example, a programmer that works with a level-5 language may not\nbe aware of the principles and mechanisms that permit his programs to be translated to a\nlevel-4 language.",
    "By analysing or operating computers with this perspective, unnecessary\ndetails can be omitted, which reduces complexity.",
    "From a programmer’s perspective, it is relevant to understand how computers work at\nthe lower levels.",
    "For most cases, knowing what happens in the underlying levels is not\nmandatory.",
    "However, when for example a program written in a high-level language does\nnot execute as expected, is not running as fast as intended, or consumes too much energy,\nit is often necessary to analyse what is happening at the lower levels.",
    "This analysis is only\npossible if the programmers comprehend how computers operate at those levels.",
    "[HEADER] 1.2 Organization of a computer.",
    "A computer is a complex system that contains millions of elementary electronic compo-\nnents.",
    "To abstractly describe a computer, it is essential to follow an hierarchical approach.",
    "Almost all uniprocessor (or scalar) computers follow the so-called von Neumann architec-\nture , which includes a CPU, the main memory, and some input/output devices, as shown in\nFig.",
    "1.2 .",
    "The existence of two separate components, one for processing the data and a dif-\nferent one to store them, is a distinguished characteristics of this architecture.",
    "All transfers\nof information between these two units go through the unique channel connecting them,\nwhich constitutes a serious bottleneck.",
    "This architecture also introduces the stored program\nconcept that makes computers to be general-purpose machines.",
    "This section introduces the\nmajor components of the computer and the way they are interconnected.",
    "The von Neumann architecture has been extended in several ways to address some of its\nlimitations.",
    "A well-known proposal, as illustrated in Fig.",
    "1.3 , is the inclusion of a system bus\n5\nESSENTIALS OF COMPUTING SYSTEMS\nI/O\ndevices\nALU\nregisters\ncontrol\nunit\nCPU\nmain\n[HEADER] memory.",
    "Fig.",
    "1.2",
    "The von Neumann architecture.\n\nthat connects the components of the computer.",
    "The system bus has three main elements:\ndata bus, address bus, and control bus.",
    "The data bus moves data from main memory to the\nCPU registers (and vice versa).",
    "The address bus holds the address of the data that the data\nbus is currently accessing.",
    "The control bus carries the necessary control signals that specify\nhow the information transfer is to take place.",
    "CPU\ncontrol\nunit\nALU\nregisters\nbus\nmain\nmemory\ndisk\nprinter\nI/O devices\n�\n��\n[HEADER] �.",
    "Fig.",
    "1.3",
    "The system bus model.",
    "[HEADER] 1.2.1 Central processing unit.",
    "The central processing unit (CPU) , also called processor, is the “brain” of the computer.",
    "On the machine language level, the operation of the CPU is quite straightforward.",
    "It is\nresponsible for the execution of the program, stored as a sequence of machine language\ninstructions in the main memory.",
    "Each instruction directs the CPU to perform some basic\ntask, like subtracting two numbers or moving data from one register to another one.",
    "The\nCPU does all this mechanically, without understanding what is the purpose for executing\nthe instruction.",
    "This means that the program must be complete and have no errors, since\nthe CPU can only execute it.",
    "The CPU is composed of three major components: control unit, ALU, and registers.",
    "The\ncomponents are connected by a bus , which is a collection of electric wires for conducting\naddress, data, and control signals.",
    "Buses allow the parallel movement of bits.",
    "At a given\nCHAPTER 1. COMPUTER SYSTEMS\n6\nmoment in time, only one device may use the bus.",
    "Buses can be external to the CPU, con-\nnecting it to memory and input/output (I/O) devices, but also internal to connect its parts.",
    "The CPU contains a small number of high-speed memory registers.",
    "A register is used to\nstore temporary results (like a number) and status information.",
    "All the registers have usually\nthe same size, that is, an equal number of bits.",
    "Registers can be read and written at a very\nhigh speed since they are internal to the CPU.",
    "A relevant register is the instruction pointer\n(IP) , also known as program counter (PC), which indicates the address of the next instruction\nto be executed.",
    "Another important register is the instruction register (IR) , which stores\nthe instruction, codified according to the machine convention, currently being executed.",
    "Most computers have other registers as well, some of them general-purpose and others for\nspecific purposes.",
    "The arithmetic logic unit (ALU) performs basic operations such as addition, subtractions,\nand comparisons, which are necessary to execute the instructions.",
    "Usually, an ALU has two\ndata inputs and one data output.",
    "The operations carried on by the ALU affect the status\nregisters, which indicate attributes related to the last arithmetic or logic operation (e.g., if\nthe result was negative or not).",
    "The operation that the ALU must perform is signalised by\nthe control unit, based on the instruction that is executed in each instant.",
    "The control unit is responsible for orchestrating the components of the computer to\nensure that the instruction that is being executed in each moment produces its exact and\nexpected effects.",
    "This is accomplished by activating in the right sequence the control signals\nthat are sent to the computer components.",
    "From a conceptual point of view, the execution\nof an instruction by the CPU can be divided into the following steps:\n1.",
    "Fetch the instruction from memory and store it into the IR.",
    "2.",
    "Determine the type of instruction.",
    "3.",
    "If a word in memory is used by the instruction, determine its location.",
    "4.",
    "If needed, transfer the word from the memory into a CPU register.",
    "5. Produce the effects of the instruction, i.e., perform some simple operation dictated by\nthe instruction.",
    "6. Change the IP to refer to the next instruction.",
    "This process, called the fetch-decode-execute cycle , is repeated indefinitely, from the\ntime that power is applied to the computer, until it is powered off.",
    "The CPU receives an\ninstruction from the memory, decodes it, and executes it using data obtained from the\nmemory or already available in the registers.",
    "Once the processor finishes the execution of\nan instruction, it starts the cycle again for the next instruction in the memory, except when\na branch instruction was just executed.",
    "This cycle is a central concept to the operation of\ndigital computers, since essentially they all just execute instructions, one after the other.",
    "The control unit can be seen as a program (a microprogram that can be implemented in\nhardware) that goes through the set of steps to execute the instructions of another program\n(i.e., the one that is being executed by the processor).",
    "Most computer systems have a clock signal that acts like a heartbeat.",
    "The clock signals\nthe passage of time within the computer.",
    "A clock emits periodically a pulse, i.e., it transmits\na precise pulse with regular intervals of high and low values.",
    "The time between two con-\nsecutive ticks is called a clock cycle (or clock period), which represents one discrete time\nunit.",
    "The different operations performed by a processor, such as fetching an instruction or\ndecoding it, are synchronised by the clock.",
    "All these operations begin with the pulse of the\n7\nESSENTIALS OF COMPUTING SYSTEMS\nclock.",
    "Therefore, the speed at which the instructions are executed by the processor depends\non the frequency of the clock, measured in cycles per second or Hertz (Hz).",
    "[HEADER] 1.2.2 Main memory.",
    "The main memory is the component of the computers, where programs and data are both\nstored.",
    "A memory consists of a number of cells or locations, each of which can store a piece\nof information.",
    "Each cell has a number, called its address , by which programs can refer to\nit.",
    "A memory with n cells uses addresses from 0 to n − 1 .",
    "All memory cells have the same\nnumber of bits.",
    "The main memory is a random access memory (RAM) , which stores a piece of data at a\nunique address and can recall the data upon presentation of the complete unique address.",
    "This is an important aspect, since microprocessors access the memory to fetch instructions\nand to read or write data in consecutive clock cycles.",
    "The addresses of these instructions\nand data need not be somehow related in a discernible way.",
    "In fact, RAM is able to handle\nrandom, or more precisely arbitrary, access, that is, any datum can be retrieved as quickly\nas any other, without favouring any particular location.",
    "RAM memories are volatile, which\nmeans that the information disappears if the supply voltage is turned off.",
    "In contrast, the\ncontents of nonvolatile memory is preserved even after power is removed.",
    "For example,\nthe flash memory used in digital cameras is nonvolatile, since the data is not lost when the\npower is turned off.",
    "Physically, the main memory consists of a collection of dynamic random\naccess memory (DRAM) chips.",
    "The cell is the smallest addressable unit.",
    "Almost all modern computers use 8-bit (1 byte)\ncells.",
    "Bytes are grouped into words.",
    "A computer with a 32-bit word has 4 bytes/word, while\na computer with a 64-bit word has 8 bytes/word.",
    "The word is also important since most\ninstructions operate on entire words, for example, adding two words together.",
    "Thus, a 32-\nbit machine has 32-bit registers and instructions for manipulating 32-bit words.",
    "An issue that needs to be handled, when storing a multibyte value in a byte-addressable\nmemory, is the order of the individual bytes.",
    "For example, the number 11 0000 0000 2 (rep-\nresented in base two as explained in Chapter 3 ) requires two bytes of memory, one storing\nthe low set of eight bits 0000 0000 2 and another one storing the high set of eight bits 0000\n0011 2 (leading zeros are added).",
    "If this value is to be stored in the memory at location 2104,\nthere are two popular ordering alternatives as shown in Fig. 1.4 .\n...\n...\n...\n...",
    "00000000\n00000011\n00000011\n00000000\n2103\n2104\n2105\n2106\n(a)",
    "[HEADER] (b).",
    "Fig.",
    "1.4 Byte ordering for multibyte: (a) Little-endian, (b) Big-endian.\n\nCHAPTER 1.",
    "COMPUTER SYSTEMS\n8\nIf the low order byte of a multibyte value is put first in memory (i.e, has the lowest\naddresses), little endian is the adopted alternative.",
    "Otherwise, if the high order bytes comes\nfirst, big endian is the selected order.",
    "In both cases, the two-byte number has address 2104,\nbut occupies also the memory cell with address 2105.",
    "Digital computers possess a great versatility.",
    "They are machines with finite hardware that\ncan execute whatever programs their users wish.",
    "1",
    "This outstanding flexibility is related to\nthe ability of a computer to load the programs in its internal memory.",
    "So, instructions and\ndata are both stored in the memory.",
    "By changing the program in the memory, one changes\nthe problem the computer is solving.",
    "This justifies the notion of a stored program computer\n(or general-purpose computer), one that can be used for any problem.",
    "2",
    "Additionally, dur-\ning a computation, a given instruction may also be modified, i.e., changed to a different\ninstruction, a characteristic that is not usually explored.",
    "This gives rise to self-modifying\ncode , a concept that is particularly straightforward to perform at the machine-level, by di-\nrectly writing new instructions over the existing ones in the memory.",
    "The stored program\nconcept is a fundamental element of many computer models, namely the universal Tur-\ning machine and the von Neumann machine.",
    "The Turing machine , a mathematical model\nof a simple computer, can be used mainly to analyse the logical foundations of computer\nsystems.",
    "[HEADER] 1.2.3 Secondary memory.",
    "The main memory of a computer is never enough, because people always need to store\nmore information than it can hold.",
    "The traditional solution to store a great quantity of data\nis to use a memory hierarchy, as illustrated in Fig. 1.5 .",
    "The top level includes the CPU regis-\nters, which constitute the fastest memories of the computer.",
    "Next come one or more cache\nmemories, which according to Table 1.5 , are on the order of 32 KiB to a few megabytes.",
    "Main\nmemory is the next level, with sizes ranging from 1 GiB for low-end systems to hundreds\nof gibibytes for high-end ones.",
    "Afterwards, come local secondary storage, which include\nlocal disks, magnetic tape and optical disks for archival storage.",
    "The final level is remote\nsecondary storage, which includes disks on remote servers that can be accessed over a\nnetwork.",
    "The overall goal of this hierarchy is to establish a memory system with cost almost as\nlow as the cheapest level and speed almost as fast as the fastest level.",
    "All the data in a\ngiven level can be found in the next lower level.",
    "Each level in this hierarchy is smaller,\nfaster and more expensive per bit than the lower ones.",
    "In fact, three parameters increase\nas the hierarchy is visited from the top to the bottom, as shown in Fig.",
    "1.5 and in Table 1.1 .",
    "Firstly, the access time gets bigger.",
    "CPU registers can be accessed in a nanosecond or\nless.",
    "Cache memories use static random access memory (SRAM) technology and take a small\nmultiple of CPU registers.",
    "Main memory accesses are typically 10 nanoseconds.",
    "The biggest\n1 Early computers had fixed programs.",
    "To modify the program, one was supposed to re-wire and re-structure\nthe machine, which was very tedious and error-prone.",
    "2 There are problems that computers cannot solve.",
    "An interesting discussion about the limits of computers\nis presented by Harel ( 2000 ).",
    "9\nESSENTIALS OF COMPUTING SYSTEMS\nregisters\nL1-cache\nL2-cache\nmain memory\nlocal secondary storage\nremote secondary storage\nspeed\nsize\n[HEADER] cost.",
    "Fig.",
    "1.5 A six-level memory hierarchy; Adapted from Bryant and O’Hallaron ( 2016 ).",
    "level\n1\n2\n3\n[HEADER] 4.\n\nname\nregisters\ncache\nmain memory disk storage\ntypical size\n< 1KB\n< 16 MB\n< 512 GB\n> 1 TB\nimplementation\nCMOS\nSRAM\nDRAM\nmagnetic disk\naccess time (ns)\n0.25–0.5\n0.5–25\n50–250\n5,000,000\nbandwidth (MB/sec) 50,000–500,000 5000–20,000 2500–10,000 50–500\nTable 1.1 Typical levels in the memory hierarchy of a desktop computer; Adapted from Hennessy and Pat-\nterson ( 2007 , p. C-3).",
    "gap occurs in the interface between the main memory and the disk, as disk access times\nare at least 10 times slower for solid-state disks (and much slower for magnetic disks).",
    "Tape\nand optical disk access can be measured in seconds if the media have to be fetched and\ninserted into a drive.",
    "Secondly, the storage capacity also increases.",
    "CPU registers are good for a small number\nof bytes.",
    "IA32, whose instruction set is described in detail in Chapter 4 , has eight 4-byte\ngeneric registers, i.e., 32 bytes.",
    "Caches, which are presented and discussed in detail in Chap-\nter 5 , can store tens of megabytes, while main memories a few gigabytes.",
    "Solid-state disks\nhave space for hundreds of gigabytes, and magnetic disks for terabytes.",
    "Tapes and optical\ndisks are usually kept off-line, so their capacity depends mainly on the owner’s budget.",
    "Thirdly, the number of bits that one gets per dollar (or euro) increases down the hierarchy.",
    "Programmers need to understand the memory hierarchy, because it has a big impact on\nthe performance of the software programs.",
    "The more distant the data is to the CPU, the\nlonger it takes to access it.",
    "[HEADER] 1.2.4 I/O devices.",
    "Computers are built so that they can be expanded with new I/O (input/output) devices,\nsuch as a hard disk, a keyboard, a mouse, a monitor, a printer, an audio output device, a\nnetwork interface, a scanner.",
    "An I/O device is a hardware system used by humans or systems\nCHAPTER 1.",
    "COMPUTER SYSTEMS\n10\nto communicate with a computer.",
    "The CPU must communicate with and control all these\ndevices.",
    "So, for each device in a system, there is a device driver , which consists of software\nthat the CPU executes when it has to deal with that device.",
    "A new device can be installed\nby connecting the device into the computer and installing its device driver software.",
    "The\ndevice driver allows the CPU to communicate with the respective device.",
    "As Fig.",
    "1.2 shows, the I/O devices are connected to the computer through busses, which\ncarry data, addresses, and control signals.",
    "An address directs the data to a specific device and\nprobably to a particular element within that device.",
    "Control signals are used, for example,\nby a device to alert the CPU that data is available on the data bus.",
    "When a given device produces data that needs to be processed, somehow the CPU needs\nto take some action.",
    "A simple solution, which is not very satisfactory, is for the CPU to keep\nchecking for incoming data over and over.",
    "Whenever it detects that data was made available\nby the device, it processes it.",
    "This method is designated as polling , since the CPU repeatedly\nchecks the input device to see whether it has any data.",
    "Polling is very simple, but is also\nvery inefficient.",
    "To avoid this inefficiency, interrupts are generally used instead of polling.",
    "An interrupt is\na signal sent by a device to the CPU to request its attention.",
    "The CPU reacts by suspending\nwhat it is doing to answer to the interrupt.",
    "For this purpose, the CPU saves information about\nwhat it is currently doing so that it can return to it afterwards.",
    "This information consists of\nthe contents of important internal registers such as the instruction pointer.",
    "Then the CPU\njumps to some fixed memory location and begins executing the instructions stored there.",
    "Those instructions correspond to the interrupt handler that does the processing necessary\nto respond to the interrupt.",
    "This interrupt handler is a part of the device driver for the\ndevice that issued the interrupt.",
    "Once the interrupt is processed, the CPU returns to the\nprocess that was suspended.",
    "To this end, it restores its previously saved state.",
    "For example,\nwhenever a key is pressed on the keyboard, an interrupt signal is sent to the CPU.",
    "The CPU\nresponds by suspending what it is doing, reading the key that was pressed, processing it,\nand then returning to the task it was performing just before the key was pressed.",
    "[HEADER] 1.3 Instruction-level parallelism.",
    "Improving the characteristics of computers, like performance, cost, reliability, energy con-\nsumption, is a concern for computer engineers and architects, as they aim to construct the\nmost efficient machines for the users.",
    "Performance is an inescapable issue, since making\ncomputers run faster is always relevant.",
    "One possible approach is to exploit parallelism,\nwhich can have different forms: instruction-level, data-level, and processor-level paral-\nlelism.",
    "This section discusses instruction-level parallelism with pipelining, which explores\nindividual instructions to obtain higher throughput (i.e., more instructions per time unit).",
    "With pipelining , the process of executing instructions is divided in stages, allowing mul-\ntiple instructions to be overlapped in execution.",
    "Each stage is responsible for a part of the\nprocess and all can run in parallel, thus speeding up the process.",
    "Fig.",
    "1.6 shows a possible\nfive-stage pipeline.",
    "Stage 1 (FI) is responsible for fetching the instruction from the memory\nand to place it in the IR.",
    "Stage 2 (DI) decodes the instruction, to identify its type and what\n11\nESSENTIALS OF COMPUTING SYSTEMS\noperands are needed.",
    "Stage 3 (FO) fetches the operands, either from registers or from the\nmemory.",
    "Stage 4 (EI) carries out the instruction.",
    "Stage 5 (SR) writes the result back to the\nproper destination.",
    "stage 1\nstage 2\nstage 3\nstage 4\nstage 5\nfetch\ninstruction\ndecode\ninstruction\nfetch\noperands\nexecute\ninstruction\nstore\n[HEADER] result.",
    "Fig.",
    "1.6 A 5-stage pipeline.",
    "Fig.",
    "1.7 illustrates the ideal operation of the pipeline.",
    "During the first clock cycle, stage 1\nhandles instruction 1, fetching it from memory.",
    "During cycle 2, stage 2 decodes instruction 1\nand stage 1 fetches instruction 2.",
    "During cycle 3, stage 3 fetches the operands for instruc-\ntion 1, stage 2 decodes instruction 2, and stage 1 fetches the third instruction.",
    "And so on.",
    "Thus, during the fifth cycle, stage 5 stores the result of instruction 1, while the other stages\nare operating on the subsequent instructions.",
    "STAGE\nFI\nDI\nFO\nEI\nSR\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n1\n2\n3\n4\n5\n6\n7\n8\n1\n2\n3\n4\n5\n6\n7\n1\n2\n3\n4\n5\n6\nCYCLE\n1\n2\n3\n4\n5\n6\n7\n8\n9\n[HEADER] 10.\n\nFig.",
    "1.7",
    "An ideal five-stage pipeline in action.",
    "The different stages operate in parallel, which permits this process to be accelerated.",
    "Pipelining increases the number of instructions that are simultaneously under execution.",
    "In fact, instruction throughput , which measures the number of instructions completed per\ntime unit, is improved.",
    "This improvement occurs without the need to reduce the time that\nis required to complete each individual instruction, called the latency .",
    "With a pipeline, all instructions must pass through each stage.",
    "If an instruction has no\noperand, it could skip stage 3, but to simplify the hardware and the timing, each instruc-\ntion proceeds through all stages, even if not necessary.",
    "As Fig.",
    "1.7 shows, in 10 cycles, six\ninstructions are fully executed.",
    "In fact, with this 5-stage solution, after the pipeline is full,\none instruction can be potentially executed at each clock cycle, i.e., the throughput is one\nclock cycle.",
    "This rate can be observed from cycles 5 to 10, in which six instructions are com-\npleted.",
    "Theoretically, if all stages take the same time, then there is a speed up of five, as\none individual instruction has a latency equal to five cycles.",
    "In fact, the maximum speedup\nis equal to the number of stages.",
    "CHAPTER 1.",
    "COMPUTER SYSTEMS\n12\nThe maximum theoretical speed up is however very unlikely to occur in practice, be-\ncause it is difficult to balance the time it takes to complete each stage.",
    "All stages must be\nequally balanced, otherwise the faster stages must wait for the slower ones.",
    "Additionally,\nthe following three major aspects also negatively affect the theoretical speed up:",
    "1. resource conflicts,\n2. data dependencies,\n3. conditional branch statements.",
    "A resource conflict greatly affects instruction-level parallelism.",
    "This type of conflict oc-\ncurs whenever two pipeline stages need to simultaneously access the same resource (e.g.,\nmemory).",
    "For example, a conflict exists when a given stage is storing a value to the memory,\nwhile another one is fetching the instruction from memory.",
    "Fig.",
    "1.8 (a) shows this situation,\nbecause both the instruction fetch (FI) for instruction 3 and the operand fetch (FO) for in-\nstruction 1 need a simultaneous access to the memory.",
    "This conflict is usually resolved by\npermitting the operand fetch to occur, while waiting for the instruction fetch, as illustrated\nin Fig.",
    "1.8 (b).",
    "Certain conflicts can also be tackled by providing two separate pathways: one\nfor data coming from memory and another for instructions coming from memory.",
    "STAGE\nFI\nDI\nFO\nEI\nSR\n1\n2\n3\n4\n5\n1\n2\n3\n4\n1\n2\n3\n1\n2\n1\nCYCLE\n1\n2\n3\n4\n5\nidle\nidle\nidle\nSTAGE\nFI\nDI\nFO\nEI\nSR\n1\n2\n3\n4\n1\n2\n3\n1\n2\n1\n2\n1\nCYCLE\n1\n2\n3\n4\n[HEADER] 5.\n\nFig.",
    "1.8",
    "A resource conflict in a 5-stage pipeline.",
    "A data dependency occurs whenever the result of one instruction, not yet available, is\nalso the operand of a subsequent instruction.",
    "There are some solutions to handle these con-\nflicts.",
    "Special hardware can be incorporated to detect instructions whose source operands\nare destinations for instructions further up the pipeline.",
    "By inserting a delay (e.g., a nop\ninstruction that does nothing) into the pipeline, sufficient time passes and the conflict dis-\nappears.",
    "Some architectures assume that this problem is solved by the compiler, which must\nreorder instructions, so that there is a delay in loading any conflicting data, but no effect\non the program overall behaviour.",
    "Problems in the pipeline can also be caused by a branch instruction that modifies the\nnormal execution flow of a program.",
    "If the conditional branch is taken, the subsequent\ninstructions must not be executed and the pipeline must be emptied.",
    "Some architectures\npredict the outcome of a conditional branch to try to identify the instructions that will be\nexecuted next.",
    "In some cases, compilers try to solve branching issues by rearranging the\nmachine code to cause a delayed branch.",
    "An attempt is made to reorder and insert useful\ninstructions, but, if not possible, nop instructions are inserted to keep the pipeline full.\n13\nESSENTIALS OF COMPUTING SYSTEMS\nAnother alternative is to initiate fetches on both paths of the branch.",
    "When the branch is\nactually executed, the correct path is identified and the pipeline can be safely continued.",
    "[HEADER] Exercises.",
    "Exerc. 1.1 : Describe the following terms with your own words: (a) Compiler; (b) Interpreter;\n(c) Virtual machine.",
    "Exerc. 1.2 : Write a small program in a given programming language.",
    "Compile it and try to\ncalculate the ratio of source code statements to the machine language instructions gener-\nated by the compilation process.",
    "Add different types of statements to the high-level pro-\ngram, one at a time, and check how the machine language program is affected.",
    "Exerc.",
    "1.3 : On a big-endian computer, a 32-bit integer with value 00010010 00110100\n01010110 01111000 is about to be stored in the memory at location 132,104.",
    "Indicate\nwhich memory cells are affected and which values are stored in each one.",
    "Exerc. 1.4 : Consider that part of the memory of a little-endian computer contains the values\nshown in the figure.",
    "Indicate the value of a 32-bit integer if it is read from the memory\nlocation 4365.",
    "0100 0011\n0111 0000\n0000 0011\n0001 0010\n1111 1111\n0000 0000\n0000 1111\n4362\n4363\n4364\n4365\n4366\n4367\n4368\nExerc. 1.5 : In a stored-program computer, both the instructions and the data of a program\nare located in the main memory while it is executed.",
    "What are the possible implications if\na program accidentally modifies the value that is stored in a memory cell that is related to\nan instruction?\nExerc. 1.6 :",
    "In a factory, the production process of a given product goes through four steps:\npreparation, assembly, testing, and packaging.",
    "Those steps take the following times, in\nseconds, to be executed: preparation (20), assembly (30), testing (35), and packaging (35).",
    "Calculate the time needed to produce 1000 replica of the product by: (a) one single person;\n(b) four persons working in a pipeline.",
    "[HEADER] Further reading.",
    "The history of computers is a very valuable source for better understanding ma n y\nissues related to computers.",
    "Ceruzzi ( 1998 ) provides an excellent overview of the history\nof com-puting in the period 1945-2001.",
    "Another interesting material is available in the\nbook edited by Rojas and Hashagen ( 2000 ), which includes detailed descriptions about the\narchitectures of the first computers ever built.",
    "CHAPTER 1.",
    "COMPUTER SYSTEMS\n14",
    "The interested reader on issues related to computer organisation and design have sev-\neral reference books to detail the material presented here.",
    "The authoritative book authored\nby Patterson and Hennessy ( 2014 ) deserves a special attention.",
    "A good source is the book\nby Bryant and O’Hallaron ( 2016 ), because it describes the concepts underlying all computer\nsystems, but with a programmer’s perspective.",
    "The book is focused on helping programmers\nto profit from their knowledge of a computer system to write better programs.",
    "Stallings\n( 2019 ) also provide a very authoritative presentation of computer organisation and archi-\ntecture.",
    "A very detailed description of different types of secondary memory is presented by Tanen-\nbaum and Austin ( 2013 , Chapter 2).",
    "Another important reference for memory systems is\nprovided by Jacob et al. ( 2008 ).",
    "Chapter 2\n[HEADER] Representation of information.",
    "Abstract",
    "The different forms of data found in computers may be grouped in three general\ncategories: (1) the numbers used in arithmetic calculations, (2) the letters of the alphabet\nthat are combined to form words in the writing systems of the languages, and (3) other\ntypes of discrete symbols that humans use for different purposes.",
    "All computers represent\nthese types of data in binary-coded formats, i.e., with bits.",
    "Despite this fact, whenever the\ncomputer information is presented to humans, it must be transformed into numbers, letters\nof the alphabet or other symbols.",
    "This chapter introduces the main concepts and techniques\nrelated to the representation of information in a computer for the last two categories indi-\ncated above.",
    "The representation of numbers is the subject of the next chapter.",
    "[HEADER] 2.1 Digital abstraction.",
    "Analog (or continuous) systems process time-varying signals that can take on any value\nacross a continuous range of voltage, current or other metric, as Fig. 2.1 (a) shows.",
    "The\nsame happens with digital systems, but the difference is that one pretends that they do not!",
    "Digital systems have signals (inputs and outputs) that are represented by discrete (i.e., non-\ncontinuous) values.",
    "Fig. 2.1 (b) depicts a possible waveform of a signal of a digital system.",
    "The X axis represents time, while the Y axis is the measured voltage.",
    "In this case, the system\nhas two possible values represented by -5V and +5V.",
    "This type of system is called binary\ndigital system.",
    "Thus, a digital signal is modelled as taking on, at any instant, only one of\ntwo possible values, which are designated as ‘0’ and ‘1’ (or ‘low’ and ‘high’, ‘false’ and ‘true’,\n‘inactive’ and ‘active’, ‘down’ and ‘up’, etc.).",
    "There is nothing intrinsic to the digital approach that limits it to only two values.",
    "The\nfundamental aspect is that the set of possible values is finite.",
    "The simplest form of digital\nsystems is binary, where there are two possible values for the signals.",
    "The more values that\nmust be distinguished, the less separation between adjacent values, and the less reliable is\nthe mechanism.",
    "Thus, the binary numeral system is the most reliable method for encoding\ndigital information, since it is easier to distinguish two possible values with physical enti-\nties than, say, five or ten.",
    "In particular, binary-coded information is the simplest one to use\n15\nCHAPTER 2. REPRESENTATION OF INFORMATION\n16\n+5\nV\n-5\ntime\n+5\nV\n-5\ntime\n1\n0\n1\n(a)",
    "[HEADER] (b).",
    "Fig. 2.1 (a) analog and (b) digital waveforms.\n\nin digital computers, since it is easy to build electronic circuits that handle two alternative\nconditions that can naturally code values ‘0’ and ‘1’.",
    "In electronic devices, the values ‘0’ and\n‘1’ might be physically realised by two different voltage values (e.g., 0 volts vs. +5 volts).",
    "However, these two values can be represented with other technologies: magnetic polarisa-\ntion (north vs. south), electrical current (flow vs. absence), relay logic (circuit open vs. circuit\nclosed), fibre optics (light off vs. light on), pneumatic logic (fluid at low pressure vs. fluid\nat high pressure).",
    "The greatest advantage of digital systems is their rigorous formulation\nbased on mathematical logic and Boolean algebra.",
    "The fundamental advantage of digital systems with respect to analog ones is their ability\nto deal with electrical signals that have been degraded by transmission through the circuits.",
    "Due to the discrete nature of the output signals, a small variation in an input value is still\ninterpreted correctly.",
    "In analog circuits, this behaviour does not occur as a slight error at an\ninput generates an error at the output.",
    "Digital circuits deal with analog voltages and currents.",
    "The digital abstraction allows\nanalog behaviour to be ignored, so circuits can be modelled as if they really process 0s and\n1s.",
    "[HEADER] 2.2 Bits, bytes and words.",
    "The digital abstraction hides the problems of the analog world by mapping the infinite set\nof real values for a physical quantity into two subsets.",
    "These two subsets correspond to two\npossible numbers or logic values: 0 and 1.",
    "Consequently, digital circuits can be analysed in\ntheir functionality using Boolean algebra.",
    "A logic value, 0 or 1, is often called a bit , a short\nform for binary digit.",
    "In isolation, a single bit is not very useful, since it just permits to represent two possible\nvalues.",
    "However, if more values need to be represented, additional bits can be considered.",
    "When bits are grouped and coded, the elements of any finite set can be represented.",
    "This can\nbe achieved by assigning some interpretation that gives meaning to the different possible\nbit patterns.",
    "With n bits, a maximum of 2 n different entities can be represented.",
    "Groups\nof bits can be used to encode numbers, as explained in Chapter 3 .",
    "By using a standard\ncharacter code, the letters and symbols in a document can also be encoded with a set of\nbits.",
    "Music, images, video and other media can also be digitally represented.",
    "In fact, all\ninformation that is processed by computers is represented by patterns of bits, often long\n17\nESSENTIALS OF COMPUTING SYSTEMS\nones.",
    "In any case, a group of bits has no meaning of its own, nor anything that intrinsically\nindicates what its representation is.",
    "Its meaning is given by the instructions that uses those\nbits.",
    "A block of 8 bits, designated as a byte , is the smallest addressable unit of memory in\nmost computers.",
    "Each half of a byte is called a nibble , which can be represented by a 4-bit\npattern or a hexadecimal digit (see Section 3.2 ).",
    "1 0 1 0 0 1 1 1\n[HEADER] byte.",
    "nibble\n[HEADER] bit.",
    "Fig.",
    "2.2",
    "A byte.",
    "The unit symbol for the byte is the upper-case letter B. 1",
    "For multiple-byte units, it is\ncommon to use systems based on powers of 10 or 2.",
    "Unfortunately, the nomenclature for\nthese systems has promoted some confusion.",
    "Systems based on powers of 10 use the stan-\ndard prefixes (kilo, mega, giga, ...) and the respective symbols (k, M, G, ...).",
    "Systems based on\npowers of 2 are supposed to use binary prefixes (kibi, mebi, gibi, ...) and the corresponding\nsymbols (Ki, Mi, Gi, ...).",
    "Table 2.1 presents the metrics for both the decimal and the binary\nsystems.",
    "decimal\nbinary\nvalue\nmetric\nvalue\nmetric\n10 3\n1000\nkB kilobyte\n2 10 1024\nKiB kibibyte\n10 6 1000 2 MB megabyte 2 20 1024 2 MiB mebibyte\n10 9 1000 3\nGB gigabyte\n2 30 1024 3\nGiB gibibyte\n10 12 1000 4\nTB terabyte\n2 40 1024 4\nTiB tebibyte\n10 15 1000 5\nPB petabyte\n2 50 1024 5 PiB pebibyte\n10 18 1000 6\nEB exabyte\n2 60 1024 6 EiB exbibyte\n10 21 1000 7 ZB zettabyte",
    "[HEADER] 2 70 1024 7 KiB zebibyte.",
    "Table 2.1 Multiple-byte units.",
    "A machine-level program views main memory as a large array of bytes.",
    "Every byte in\nthe memory is identified by a unique number, its address.",
    "Fig.",
    "2.3 shows a memory with\n256 locations (or cells), each one storing one byte.",
    "To specify each memory location, a 8-bit\naddress is needed.",
    "It is important to distinguish the memory address from its contents.",
    "In\nthe figure, the contents of memory cell 0000 0100 is 1100 0110.",
    "A word is the basic unit of data handled by a given family of computers.",
    "The sizes of\nwords historically range from four bits, for early microprocessors like the Intel 4004, to\n60 bits, for early mainframes (CDC 6600).",
    "Modern computers have word sizes of 16, 32,\n1 B is the symbol of the bel, a unit of logarithmic power ratio named after Alexander Graham Bell, creating\na conflict.",
    "Since the bel is seldom used, little danger of confusion exists.",
    "Usually, it is used in its decadic\nfraction, the decibel (dB).",
    "CHAPTER 2. REPRESENTATION OF INFORMATION\n18\n...\n1111 1111\n1111 1110\n1111 1101\n...\n0000 0101\n0000 0100\n0000 0011\n0000 0010\n0000 0001\n0000 0000\n0100 1100\n1111 0000\n0000 0001\n...\n0100 1101\n1100 0110\n0100 0111\n0001 0000\n1110 1001",
    "[HEADER] 0010 1000.",
    "Fig.",
    "2.3",
    "A memory with 256 locations and addresses with 8 bits.\n\nor 64 bits.",
    "The word size is a relevant characteristic of any specific processor or computer\narchitecture.",
    "[HEADER] 2.3 Textual information.",
    "Text is the most common type of nonnumeric data that humans use, so computers need\nto represent it.",
    "In a computer, each alphanumeric character is represented by a bit pattern\naccording to an established convention (code).",
    "The most commonly used character encoding\nstandard is ASCII (American Standard Code for Information Interchange).",
    "The ASCII code is\nused in computers, telecommunications equipment, and other devices, and represents each\ncharacter with a 7-bit string.",
    "As Table 2.2 shows, the ASCII code includes 59 printable symbols: the digits 0 to 9, low-\nercase letters a to z, uppercase letters A to Z, and several punctuation symbols.",
    "Additionally,\n33 non-printing control codes are considered, including for example the carriage return, the\nline feed and the tab.",
    "For example, lowercase j would be represented in the ASCII encoding\nby the 1101010 binary pattern.",
    "ASCII encoding uses seven bits, but in practice, characters are not stored in groups of\n7 bits.",
    "Instead, one ASCII symbol is stored in a byte, with the leftmost bit usually set to\n0.",
    "Different manufacturers extended the ASCII code to take advantage of the 8th bit.",
    "The\ngeneral idea was to have 128 additional characters for the bit patterns whose leftmost bit\nis 1.",
    "A string, like for instance the English word “Digital”, is encoded in the C programming\nlanguage by an array of ASCII characters, terminated by the null character, whose ASCII\ncode is ‘00000000’.",
    "So, this word to be represented needs eight characters, i.e., 64 bits, as\ndepicted in Fig. 2.4 .",
    "The set of symbols provided by ASCII is too short, since there are many different sym-\nbols in the various alphabets.",
    "ASCII does not include several accents used in European lan-\nguages or larger alphabets, such as Cyrillic (the Russian alphabet) and Chinese Mandarin.",
    "Thus, modern computers use Unicode , which is a standard for the encoding, representa-\ntion, and handling of text expressed in most of the world’s writing systems.",
    "It provides the\n19\n[HEADER] ESSENTIALS OF COMPUTING SYSTEMS.",
    "binary\nchar\nbinary\nchar binary\nchar binary\n[HEADER] char.\n\n0000000\nNUL - null\n0100000 space 1000000\n@\n1100000\n`\n0000001\nSOH - start of header\n0100001\n!\n1000001\nA\n1100001\na\n0000010\nSTX - start of text\n0100010\n\"\n1000010\nB\n1100010\nb\n0000011\nETX - end of text\n0100011\n#\n1000011\nC\n1100011\nc\n0000100\nEOT - end of transmission\n0100100\n$\n1000100\nD\n1100100\nd\n0000101\nENQ - enquiry\n0100101\n%\n1000101\nE\n1100101\ne\n0000110\nACK - acknowledge\n0100110\n&\n1000110\nF\n1100110\nf\n0000111\nBEL - bell\n0100111\n'\n1000111\nG\n1100111",
    "g\n0001000\nBS - backspace\n0101000\n(\n1001000\nH\n1101000\nh\n0001001\nHT - horizontal tab\n0101001\n)\n1001001",
    "I\n1101001\ni\n0001010\nLF - line feed\n0101010\n*\n1001010\nJ\n1101010\nj\n0001011\nVT - vertical tab\n0101011\n+\n1001011\nK\n1101011\nk\n0001100\nFF - form feed\n0101100\n,\n1001100\nL\n1101100\nl\n0001101\nCR - carriage return\n0101101\n-\n1001101\nM\n1101101\nm\n0001110\nSO - shift out\n0101110\n.",
    "1001110\nN\n1101110\nn\n0001111\nSI - shift in\n0101111\n/\n1001111\nO\n1101111\no\n0010000\nDLE - data link escape\n0110000\n0\n1010000\nP\n1110000\np\n0010001\nDC1 - device control 1\n0110001\n1\n1010001\nQ\n1110001\nq\n0010010\nDC2 - device control 2\n0110010\n2\n1010010\nR\n1110010\nr\n0010011\nDC3 - device control 3\n0110011\n3\n1010011\nS\n1110011\ns\n0010100\nDC4 - device control 4\n0110100\n4\n1010100\nT\n1110100\nt\n0010101 NAK - negative acknowledge 0110101\n5\n1010101",
    "U\n1110101\nu\n0010110\nSYN - synchronize\n0110110\n6\n1010110\nV\n1110110\nv\n0010111\nETB - end transm.",
    "block\n0110111\n7\n1010111\nW\n1110111\nw\n0011000\nCAN - cancel\n0111000\n8\n1011000\nX\n1111000\nx\n0011001\nEM - end of medium\n0111001\n9\n1011001\nY\n1111001\ny\n0011010\nSUB - substitute\n0111010\n:\n1011010\nZ\n1111010\nz\n0011011\nESC - escape\n0111011\n;",
    "1011011\n[\n1111011\n{\n0011100\nFS - file separator\n0111100\n<\n1011100\n\\\n1111100\n|\n0011101\nGS - group separator\n0111101\n=\n1011101\n]\n1111101\n}\n0011110\nRS - record separator\n0111110\n>\n1011110\n^\n1111110\n˜\n0011111\nUS - unit separator\n0111111\n?\n1011111\n_",
    "[HEADER] 1111111 DEL.\n\nTable 2.2",
    "The ASCII table.",
    "D\ni\ng\ni\nt\na\nl\n‘\\0’",
    "[HEADER] 01000100 01101001 01100111 01101001 01110100 01100001 01101100 00000000.",
    "Fig.",
    "2.4 Binary pattern for the string “Digital”.",
    "capacity to represent all characters used for the written languages, since more than one\nmillion characters can be encoded.",
    "As of March 2020, Unicode has a total of 143,859 char-\nacters.",
    "Unicode 13.0 covers 154 modern and historic scripts, as well as multiple symbol\nsets and emoji.",
    "Unicode can be implemented by different character encodings, like UTF-8,\nUTF-16, and UTF-32.",
    "UTF-8 is currently the dominant encoding on the World Wide Web.",
    "Unicode is the representation scheme adopted by modern standards, such as CORBA 3.0,\nJava, LDAP, WML, and XML.",
    "The majority of the common-use characters fit into the first 64k\ncode patterns, which just require two bytes (16 bits).",
    "CHAPTER 2. REPRESENTATION OF INFORMATION",
    "[HEADER] 20.",
    "[HEADER] 2.4 Machine-level instructions.",
    "A computer program is a sequence of instructions.",
    "At the machine-level, each instruction\nis represented by a bit pattern.",
    "Generally, it consists of an opcode and some additional\ninformation, such as where operands come from and where to store the results.",
    "Fig. 2.5\nshows several possible formats for machine-level instructions.",
    "An instruction always has\nan opcode to indicate what operation is to be performed.",
    "The number of arguments (or\noperands) varies from zero to three, depending on the instruction and on the general format\nconsidered by the specific processor.",
    "opcode\nopcode\narg\nopcode\narg1\narg2\nopcode\narg1\narg2\narg3\n(a)\n(c)\n(b)\n(d)\nFig.",
    "2.5 Four common instruction formats: (a) Zero-argument instruction; (b) One-argument instruction; (c)\nTwo-argument instruction; (d) Three-argument instruction.",
    "On some machines, all instructions have the same length; on others there may be many\ndifferent lengths.",
    "The opcode for each instruction type must be associated with a unique\nbit pattern, to identify it univocally.",
    "The instructions of the MIPS processor all have 32 bits.",
    "They are classified according to five different types (R, I, J, FR, FI).",
    "The R instructions have\nall the data values located in registers.",
    "The syntax of the R instructions is:\nOP rd, rs, rt\nwhere OP is the mnemonic for the particular instruction, rs and rt are the source registers,\nand rd is the destination register.",
    "The machine code for an R instruction has the following\nformat:\nopcode\nrs\nrt\nrd\nshamt\nfunct\n6 bits\n5 bits\n5 bits\n5 bits\n5 bits\n6 bits\nAn example of an R instruction is:\nadd $t1, $t2, $t3\nwhere $t1, $t2, and $t3 are registers.",
    "This instruction adds the values of registers $t2 and\n$t3 and stores the result in register $t1.",
    "This instruction is represented by the following bit\npattern:\n000000 01010 01011 01001 00000 100000\nThe I instructions are used when the instruction operates on an immediate value and a\nregister value.",
    "Their syntax is:\nOP rd, rs, IMM\n21\nESSENTIALS OF COMPUTING SYSTEMS\nwhere OP is the mnemonic for the particular instruction, rs is the source register, IMM is\nan immediate value (with a maximum of 16 bits), and rd is the destination register.",
    "The\nmachine code for an I instruction has the following format:\nopcode\nrs\nrt\nIMM\n6 bits\n5 bits\n5 bits\n16 bits\nAn example of an I instruction is an addition instruction that adds 100 to the contents\nof register $t2 and stores the result in register $t1:\naddi $t1, $t2, 100\nThis instruction is represented by the following bit pattern:",
    "[HEADER] 001000 01010 01001 0000000001100100.",
    "[HEADER] 2.5 Images.",
    "A digital image can be represented by a grid of small points.",
    "This image is a raster image\n(or simply bitmap image) as it is seen as an array of points.",
    "Each point is called a pixel\n(short for picture element) and is represented by a binary pattern.",
    "Black and white images\nrepresent, for example, black by ‘1’ and white by ‘0’.",
    "Thus, each black and white image is\na set of 0s and 1s.",
    "To draw the picture, a grid must be defined and the squares coloured\naccordingly.",
    "If an image has size 4x6 (in pixels), then an ‘A’ can be drawn with by the grid\nin Fig.",
    "2.6 (a), whose sequence of bits from bottom to top and from let to right is 01101001\n10011111 10011001.",
    "0\n1\n1\n0\n1\n0\n0\n1\n1\n0\n0\n1\n1\n1\n1\n1\n1\n0\n0\n1\n1\n0\n0\n1\n(a)\n00\n00\n00\n00\n00\n11\n00\n00\n11\n11\n11\n00\n01\n01\n01\n00\n01\n00\n01\n00\n10\n10\n10\n10\n[HEADER] (b).",
    "Fig. 2.6 (a) Black and white image, (b) coloured image.",
    "The size of the image needs to be stored and is part of the metadata (data about data)\nof an image.",
    "Other examples of metadata are the date and the time when the image was\ncreated, the name of its creator, and the type of compression used to store the image.",
    "CHAPTER 2. REPRESENTATION OF INFORMATION\n22",
    "Adding colours to a picture entails enlarging the number of bits that are used to rep-\nresent each pixel.",
    "If two bits are used, four colours can be represented.",
    "For example, if\nthe following encoding is used (‘00’ white, ‘01’ blue, ‘10’ green, and ‘11’ red), the image\nin Fig. 2.6 (b) is represented by the bit pattern 00000000 00110000 11111100 01010100\n01000100 10101010.",
    "Many image formats use the RGB (Red-Green-Blue) colour model.",
    "RGB has three channels to define a wide assortment of colours.",
    "RGB was originally created\nto represent and display images in electronic devices, such as TV sets and computers, but\nit has also been used in photography and digital images.",
    "If each channel has 8 bits and all\nchannels are at 0, a pure black colour is obtained.",
    "Similarly, if all channels are at 255, an\nall-white colour is defined.",
    "By adjusting the red, green, and blue channels, many different\ncolour can be defined, including grays, whites, and blacks.",
    "The number of bits used to store each pixel is called the colour depth .",
    "Images with more\npossible colours require obviously more bits to specify each one, so they are stored in larger\nfiles.",
    "The image quality depends on the image resolution , which is related to how close the\npixels are.",
    "It is usually measured in dots per inch (dpi), 2 that is, the number of dots/pixels\nthat can be placed in a line within the span of 1 inch (2.54 cm).",
    "In a low-resolution image,\nthe pixels are larger so fewer are needed to fill the space.",
    "This results in images that may\nlook pixelated.",
    "An image with a higher resolution has more pixels, so it looks better when\nit is zoomed in.",
    "The disadvantage of having more pixels is that the file size is larger.",
    "A vector image uses scalable shapes, such as lines and curves.",
    "Coordinates and geometry\nare used to precisely define the elements of the image.",
    "It is more efficient than bitmaps\nat storing, for example, large areas of the same colour, since it does not need to store\nevery pixel as a bitmap image does.",
    "Additionally, a vector image can be scaled (enlarged or\nreduced in size), without losing quality.",
    "[HEADER] 2.6 Audio.",
    "Sound waves in nature have an analog nature.",
    "To process sound (or audio), computers need\nto convert it into a digital format.",
    "Firstly, sound is recorded using a device, like a microphone,\nthat translates sound waves into an electrical signal, as illustrated in Fig.",
    "2.7 (a).",
    "Then, pe-\nriodic measurements of the level of that signal are registered, as shown in Fig.",
    "2.7 (b).",
    "This\nprocess that reduces a continuous-time signal to a discrete-time signal is called sampling .",
    "The value (or set of values) at a point in time is designated sample .",
    "The samples are then\nsimply converted into binary, using a unique binary code.",
    "Afterwards, the digital sound can\nbe processed by a computer as a sequence of bits.",
    "The sample resolution is the number of bits used to represent the value of each sample.",
    "If more bits are available for each sample, then more levels of the signal can be captured,\nwhich improves the precision of the recording.",
    "When Fig. 2.7 (b) and (c) are compared, it\nshould be clear that the latter has higher precision.",
    "The digital sample in (b) has a low\nsampling resolution when compared to the digital sample in (c).",
    "The minimum step of two\nconsecutive digital values in the former corresponds to 1 V (the value is rounded to the\nnearest whole number: 0, 1, 2, ...), while in the latter to 0.5 V (the value is rounded to\n2 Other metrics also exist, like dots per centimetre and pixels per inch.\n23\nESSENTIALS OF COMPUTING SYSTEMS\nthe nearest half integer: 0, 0.5, 1.0, ...).",
    "The sample in (c) is thus more accurate, i.e., it has\nsmaller rounding errors.",
    "time\nV\n+5\n+4\n+3\n+2\n+1\n0\ntime\nV\n+5\n+4\n+3\n+2\n+1\n0\ntime\nV\n+5\n+4\n+3\n+2\n+1\n0\ntime\nV\n+5\n+4\n+3\n+2\n+1\n0\n(a)\n(b)\n(c)\n(d)\nFig.",
    "2.7 (a) analog audio signal; digital signals with (b) a low sampling rate and a low sample resolution,\n(c) a high sampling resolution, (d) a high sampling rate.",
    "The number of samples taken per second, measured in Hertz (Hz), is the sampling rate .",
    "The higher the sampling rate, the better the quality of the audio digital signal, because,\nif there are more samples, the original sound can be represented more accurately.",
    "When\nFig. 2.7 (b) and (d) are compared, it is clear that the latter has more quality, that is, it repre-\nsents with more accuracy the original signal.",
    "To determine the size s of a sound signal in bits, three values are multiplied: s = f × r × t .",
    "In this formula, f is the sampling rate in Hertz, r is the sample resolution measured in\nnumber of bits, and t is the duration of the signal in seconds.",
    "[HEADER] Exercises.",
    "Exerc. 2.1 : To encode Roman numbers (from 1 to 899), the following binary encoding for\nthe symbols has been proposed: I (01), V (100), X (00), L (101), C (110), D (111).",
    "Indicate\nwhether this encoding is valid and, if so, what Roman number is represented by the binary\npattern 111101000101.",
    "Exerc. 2.2",
    ": Decode the following ASCII string:\n1010101 0101110 0100000 1001101 1101001 1101110 1101000 1101111.",
    "Exerc. 2.3",
    ": A digital image has 128x128 pixels.",
    "Each pixel in the image stores information\nrelated to three channels (Red, Blue, Green).",
    "If each channel is capable of distinguishing\n256 different tones, indicate the size in bytes of the image.",
    "Exerc. 2.4 : An image occupies 192 kibibytes and has dimensions of 256x512 pixels.",
    "Each\npixel is represented by three unsigned integer values, which indicate the intensity of each\nCHAPTER 2.",
    "REPRESENTATION OF INFORMATION\n24\nchannel (Red-Green-Blue) in that pixel.",
    "Indicate, in binary and decimal, the maximum value\nthat can be assigned to each of these integers, if they all have the same size.",
    "Exerc. 2.5 : The CYMK* subtractive colour system is formed by Cyan, Magenta, Yellow and\nBlack and works due to the absorption of light, as the colours that are seen come from the\npart of the light that is not absorbed.",
    "Each pixel is represented by four 6-bit patterns that\nindicate the intensity in each channel.",
    "Indicate how many different colours a pixel can have,\nassuming that the “00000-” (“000000” and “000001”) patterns cannot be used.",
    "Exerc. 2.6 : The SCB system for evaluating football players consists of three parameters:\nStrength, Courage and Braveness.",
    "Each parameter is represented by a binary pattern (of 7\nbits each) that indicates the respective intensity.",
    "Indicate the number of different valid as-\nsessments with this system, if the “1111111” and “1111110” patterns represent evaluations\nthat are still unknown or invalid, respectively.",
    "Exerc. 2.7 : Calculate the size in kB of a sound file, if the recording lasts exactly 2 minutes\nand it is sampled using a sampling rate of 50 kHz and a sample resolution of 8 bits.",
    "What\nis the size in KiB?\nExerc. 2.8 : Calculate the sample resolution of a sound file with 4.5kB, if the recording lasts\none minute with a sampling rate of 50 Hz.\nExerc. 2.9 : Consider that a typical daily newspaper page contains 3700 Unicode charac-\nters including white spaces.",
    "(a) How many bytes are needed to encode a 32-page edition\nof that daily newspaper, if it includes on average 50 photos (1.2MiB each one)?",
    "(b) How\nmany mebibytes are needed to store all the numbers of the newspaper published in a year?\n(c) If a library contains 1250 different daily newspapers, which have on average 50 years of\npublication, how many pebibytes are stored there?",
    "[HEADER] Further reading.",
    "Information theory is a field that deserves to be studied by all computer scientists.",
    "Is is\nfocused in studying the quantification, storage, and communication of information and was\nestablished by the works of Harry Nyquist, Ralph Hartley, and Claude Shannon.",
    "Extensive\nintroductions to this field are provided by McEliece ( 2005 ) and Borda ( 2011 ).",
    "Boolean algebra and logic design are classical topics in many courses related to the\nfundamentals of computers, but they are not addressed in this book.",
    "Boolean algebra allows\nthe formal treatment of logic.",
    "This is relevant since the properties of electrical switching\ncircuits can be represented by a two-valued Boolean algebra (called switching algebra).",
    "The interested reader is pointed to books by Katz ( 1994 ), Gajski ( 1997 ), and Wakerly ( 2001 ),\nwhich make a very good coverage of these fundamental topics.",
    "The reader interested in understanding the Unicode is pointed to the book written by\nthe Unicode Consortium ( 2007 ), which describes the 5th edition of this universal character\nencoding standard for written characters and text.",
    "Chapter 3\n[HEADER] Representation of numbers.",
    "Abstract This chapter introduces the different approaches and techniques used to represent\nnumeric information in computers.",
    "The positional numeral systems are described.",
    "The use\nof numbers in the octal and hexadecimal systems and the conversion between different\nbases are discussed.",
    "Different alternatives to represent integer numbers, negative numbers,\nand real numbers are also presented.",
    "The representation of decimal numbers with binary\ncodes closes the chapter.",
    "[HEADER] 3.1 Positional numeral systems.",
    "A numeral system (or number system) is a writing system for expressing numbers, that\nis, a notation for representing numbers of a given set, using digits or other symbols.",
    "To\nrepresent numbers, computers do not use the decimal numeral system used by humans, also\ncalled the Hindu–Arabic numeral system, but rather the binary numeral system.",
    "Each one\nis a positional numeral system , which represents any number by a sequence of juxtaposed\ndigits.",
    "A digit is a symbol used alone or in combinations to represent numbers in a positional\nnumeral system.",
    "The position of each digit has a corresponding weight.",
    "The mathematical\nvalue of a number is provided by the weighted sum of all its digits.",
    "For decimal integer\nnumbers, the weights are powers of ten equal to 10 i , where i is the position of the digit\nstarting from the right, as occurs in this example:\n4682 = 4 · 1000 + 6 · 100 + 8 · 10 + 2 · 1\nHere, the value 10 is called the radix (or base) of the numeral system.",
    "The value of a\ndecimal integer number D of the form d 3 d 2 d 1 d 0 is:\nD =",
    "d 3 · 10 3 + d 2 · 10 2 + d 1 · 10 1 + d 0 · 10 0\nPositional numeral systems can use any integer r ≥ 2 for the base, and the digit in posi-\ntion i has weight r",
    "i .",
    "So, the general format of a n -digit number D in such a system is:\n25\nCHAPTER 3.",
    "REPRESENTATION OF NUMBERS\n26\n[HEADER] D = d n − 1 d n − 2 ...",
    "d 1 d 0.",
    "The value of this natural number is given by the following formula:\n\nD =\nn − 1\n∑\ni = 0\nd",
    "i ·",
    "r i\n(3.1)",
    "Digital devices adopt the binary base ( r = 2 ), which uses two possible digits (0 and 1).",
    "The general format of a number B in such base is:\nB = b n − 1 b n",
    "− 2 ...",
    "b 1 b 0\nThe value of this natural number is:\nB",
    "=\nn − 1\n∑\ni = 0\nb i · 2 i\nThe typical representation for natural numbers in digital computers involves a fixed num-\nber of bits, usually 8, 16, 32, or 64.",
    "Thus, these numbers have a fixed range that is defined\nas the difference between the largest and the smallest representable numbers in a given\nnumeral system.",
    "A representation with n bits ranges from 0 to 2 n − 1 .",
    "With 8 bits, this range\ngoes from 0 to +255.",
    "The memory of a computer is organised as a linear array of bytes, each with its own\nunique address starting at zero.",
    "Memory addresses in the computer are obviously repre-\nsented as binary numbers.",
    "If an address has m bits, the maximum number of addressable\ncells is 2 m .",
    "The number of bits in the address determines the maximum number of directly\naddressable cells in the memory and does not depend on the number of bits per cell.",
    "For\nexample, one needs 10-bit addresses, either for a memory with 2 10 cells of 8 bits each or\nfor a memory with 2 10 cells of 37 bits each.",
    "The previous concepts all apply to natural numbers, but can also be extended to include\nfractions in any base system, which can be approximated using negative powers of a radix.",
    "The integer part of a number is separated from its fractional part by a radix point .",
    "In the\ndecimal system, the radix point is called decimal point .",
    "The next example shows a decimal number 1 that has two decimal digits to the right of\nthe decimal point:\n4682 .",
    "51 = 4 · 1000 + 6 · 100 + 8 · 10 + 2 · 1 + 5 · 0 . 1 + 1 · 0 . 01",
    "The value of a decimal number D of the form d 2 d 1 d 0 .",
    "d",
    "− 1 d",
    "− 2 is:\nD =",
    "d 2 · 10 2 + d 1 · 10 1 + d 0 · 10 0 + d",
    "− 1 · 10 − 1 + d − 2 · 10 − 2\nBinary fractions have a binary point .",
    "The general format of a number B in base 2, with\nm digits to the right of the radix point and n digits to the left, is:\n1",
    "The term “decimal number\" is often used as an equivalent to “decimal representation of a number\", which\nis more precise; Likewise for other representations.",
    "27\nESSENTIALS OF COMPUTING SYSTEMS\nB = b n − 1 b n − 2 ... b 1 b 0 .",
    "b − 1 b − 2 ...",
    "b",
    "− m\nThe value of this number is:\nB",
    "=\nn − 1\n∑\ni = − m\nb i · 2",
    "i\n(3.2)\nThis equation can be generalised to numbers represented in any base r .",
    "D =\nn − 1\n∑\ni = −",
    "m\nb i · r i\n(3.3)",
    "In positional numeral systems, the rightmost digit is designated as least-significant digit\n(LSD) , while the rightmost one is the most-significant digit (MSD) .",
    "For the particular case\nof binary numbers, the LSD is designated as least-significant bit (LSB) , while MSD is called\nas most-significant bit (MSB) .",
    "Whenever one uses numbers in different bases, a subscript must be used to indicate\nwhich base is used in each case.",
    "Here, are some examples of binary numbers and their\ncorresponding values in decimal.",
    "11001 2\n= 1 · 16 + 1 · 8 + 0 · 4 + 0 · 2 + 1 · 1\n= 25 10\n111001 2 = 1 · 32 + 1 · 16 + 1 · 8 + 0 · 4 + 0 · 2 + 1 · 1 = 57 10\n11 .",
    "101 2 = 1 · 2 + 1 · 1 + 1 · 0 . 5 + 0 · 0 . 25 + 1 · 0 . 125 = 3 .",
    "625 10\n[HEADER] 0 .",
    "1111 2",
    "= 1 · 0 .",
    "5 + 1 · 0 .",
    "25 + 1 · 0 . 125 + 1 · 0 . 0625",
    "= 0 . 9375 10.",
    "[HEADER] 3.2 Octal and hexadecimal numbers.",
    "Base 10 is important and useful, since humans use it in every day activities, and the same\nhappens for base 2, as binary numbers are processed by digital devices.",
    "Since the binary\nnotation is too verbose, the bases 8 (octal) and 16 (hexadecimal) are also popular among\ncomputer scientists, namely for documentation purposes.",
    "They are used to offer a shorthand\nrepresentation for binary numbers, i.e., they allow long patterns of bits to be represented\nby shorter patterns of octal or hexadecimal digits.",
    "Base 8 is adopted by the octal numeral system , whereas base 16 supports the hexadec-\nimal numeral system .",
    "The octal system uses eight different digits: 0 to 7 (0, 1, 2, 3, 4, 5,\n6, 7).",
    "Similarly, the hexadecimal numeral system uses 16 digits: 0 to 9 and the letters A to\nF (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F).",
    "Table 3.1 shows the binary numbers from 0 to\n10001 and their octal, decimal, and hexadecimal representations.",
    "Bases 8 and 16 are useful for representing multi-bit numbers, since they are integer\npowers of 2 ( 8 = 2 3 , 16 = 2 4 ).",
    "So, as indicated in Table 3.1 , octal and hexadecimal digits are\ndirectly represented by 3-bit and 4-bit strings, respectively.",
    "Therefore, converting a binary\nnumber to octal is straightforward.",
    "Starting at the binary point and moving to the left, the\nbits are separated into groups of three and each group is replaced by the corresponding\noctal digit.",
    "CHAPTER 3. REPRESENTATION OF NUMBERS\n28\n100010101001 2\n= 100 010 101 001 2\n= 4251 8\n11111100011101110 2 = 011 111 100 011 101 110 2 = 374356 8\nThe method for converting a binary number to hexadecimal is similar, but the groups are\ncomposed of four bits:\n100010101011 2\n= 1000 1010 1011 2\n= 8 AB 16",
    "[HEADER] 11111100011101110 2 = 0001 1111 1000 1110 1110 2 = 1 F 8 EE 16.\n\n3-bit\nhexa-\n4-bit\n[HEADER] binary decimal octal string decimal string.",
    "0\n0\n0\n000\n0\n0000\n1\n1\n1\n001\n1\n0001\n10\n2\n2\n010\n2\n0010\n11\n3\n3\n011\n3\n0011\n100\n4\n4\n100\n4\n0100\n101\n5\n5\n101\n5\n0101\n110\n6\n6\n110\n6\n0110\n111\n7\n7\n111\n7\n0111\n1000\n8\n10\n-\n8\n1000\n1001\n9\n11\n-\n9\n1001\n1010\n10\n12\n-\nA\n1010\n1011\n11\n13\n-\nB\n1011\n1100\n12\n14\n-\nC\n1100\n1101\n13\n15\n-\nD\n1101\n1110\n14\n16\n-\nE\n1110\n1111\n15\n17\n-\nF\n1111\n10000\n16\n20\n-\n10\n-\n10001\n17\n21\n-\n11\n[HEADER] -.\n\nTable 3.1 Different representations for binary numbers 0 to 10001.",
    "In some of these conversions, additional 0s were added to the left, which do not change\nthe value.",
    "The idea is to make the total number of bits be a multiple of 3 or 4, accordingly.",
    "Whenever a binary number contains digits to the right of the binary point, the method for\nconverting into octal and hexadecimal is also easy.",
    "Starting at the binary point and moving\nto the right, the bits are again separated in groups of three (or four) and are replaced by the\ncorresponding octal (hexadecimal) digit.",
    "Here, additional 0s can be added to the right of\nthe rightmost bit, as this operation does not change the value of the number, as intended.\n.",
    "11001 2 = .",
    "110 010 2\n= .",
    "62 8\n= .",
    "1100 1000 2 = .",
    "C 8 16\nThe conversions in the opposite direction (from octal or hexadecimal to binary) are also\nvery easy.",
    "Each octal or hexadecimal digit is simply transformed into the corresponding 3-\nor 4-bit string.",
    "1234 8\n= 001 010 011 100 2\n234 .",
    "05 8\n= 010 011 100 .",
    "000 101 2\n29\nESSENTIALS OF COMPUTING SYSTEMS\n1234 16\n= 0001 0010 0011 0100 2\nAB 3 .",
    "05 16 = 1010 1011 0011 .",
    "0000",
    "0101",
    "2\nHexadecimal numbers are often used to represent addresses in the memory space of a\ndigital computer.",
    "For instance, in a computer with 32-bit addresses, each position in the\nmemory is specified with eight hexadecimal digits, like for example A 835 B 300 16 .",
    "In many\nprogramming languages, like C, the prefix 0x is used to indicated hexadecimal numbers,\nlike 0xA835B300 .",
    "[HEADER] 3.3 Conversions between different bases.",
    "In general, the conversion from one base to another one cannot be accomplished by just\nreplacing digits in a base to the corresponding digits in the other base.",
    "This only occurs\nwhen both bases are integer powers of the same number (e.g., 2, 4, 8, and 16; 3, 9, and 27).",
    "In the other cases, arithmetic operations are needed.",
    "Equation 3.3 calculates the value of a number in base r , that has m digits to the right of\nthe radix point and n digits to the left.",
    "The value can thus be calculated by converting each\ndigit to the respective base-10 equivalent and by adding all these values.",
    "Some examples\nare given:\nAB 3 16\n= 10 · 16 2 + 11 · 16 1 + 3 · 16 0\n= 2819 10\n2345 8\n= 2 · 8 3 + 3 · 8 2 + 4 · 8 1 + 5 · 8 0\n= 1253 10\n124 .",
    "7 8\n= 1 · 8 2 + 2 · 8 1 + 4 · 8 0 + 7 · 8 − 1\n= 84 .",
    "875 10\n120 .",
    "01 3 = 1 · 3 2 + 2 · 3 1 + 0 · 3 0 + 0 · 3 − 1 + 1 · 3 − 2 = 15 .",
    "( 1 ) 10\nThe last example shows that fractions that contain repeating strings of digits to the right\nof the radix point in a given base may not necessarily have a repeating sequence of digits\nin another base.",
    "Equation 3.1 can be rewritten in order to highlight a simple procedure for converting\nnumbers to base 10\nD = (( ... (( d n − 1 ) ·",
    "r + d n − 2 ) · r + ... )",
    "· r + d 1 ) · r + d 0\n(3.4)\nWhen this formula is applied to hexadecimal number A 835 16 , the following expression\ncan be used to calculate its value:\nA 835 16 = ((( 10 ) · 16 + 8 ) · 16 + 3 ) · 16 + 5\nAlgorithm 1 calculates the decimal value of an integer number represented with n digits\nin base b .",
    "Equation 3.4 can also be used to convert a decimal number D to the equivalent num-\nber in base r .",
    "If D in Equation 3.4 is divided by r , d 0 is the remainder and the part inside\nparentheses corresponds to the quotient Q :\nQ = ( ... (( d m − 1 ) ·",
    "r + d m − 2 ) · r + ... )",
    "· r + d 1\n(3.5)\nCHAPTER 3. REPRESENTATION OF NUMBERS\n[HEADER] 30.",
    "[HEADER] Algorithm 1: calculation of the decimal value of a number in a given base.",
    "input : A number d in base b with n digits (d n − 1 d n",
    "− 2 ...",
    "d 2 d 1 d 0 )",
    "[HEADER] output: The decimal value v of number d.\n\nv ← 0 ;",
    "i ← n − 1 ;\n[HEADER] while i ≥ 0 do.",
    "v ← v · b + d",
    "i ;",
    "i ←",
    "i − 1 ;",
    "[HEADER] end.",
    "Since Q follows the same format as D , successive divisions by r yield successive digits\nof D , from right to left.",
    "Some examples illustrate how this method works for converting\ndecimal number 177 to bases 2, 8, and 16:\n177 ÷ 2 = 88\nremainder 1\n177 ÷ 8 = 22\nremainder 1\n88 ÷ 2 = 44\nremainder 0\n22 ÷ 8 = 2\nremainder 6\n44 ÷ 2 = 22\nremainder 0\n2 ÷ 8 = 0\nremainder 2\n22 ÷ 2 = 11\nremainder 0\n177 10 = 261 8\n11 ÷ 2 = 5\nremainder 1\n5 ÷ 2 = 2\nremainder 1\n2 ÷ 2 = 1\nremainder 0\n177 ÷ 16 = 11\nremainder 1\n1 ÷ 2 = 0\nremainder 1\n11 ÷ 16 = 0\nremainder 11\n177 10 = 10110001 2\n177 10 = B 1 16\nThe methods just described can be followed to directly convert any number in a given\nbase to any other base.",
    "However, often, it is easier to first convert to the decimal base and\nthen to the target base.",
    "The next example shows how to convert 3410 5 to base 3:\n3410 5 = 3 · 5 3 + 4 · 5 2 + 1 · 5 1 + 0 · 5 0 = 480 10\n480 ÷ 3 = 160\nremainder 0\n160 ÷ 3 = 53\nremainder 1\n53 ÷ 3 = 17\nremainder 2\n17 ÷ 3 =\n5\nremainder 2\n5 ÷ 3 =\n1\nremainder 2\n1 ÷ 3",
    "=\n0\nremainder",
    "1\n[HEADER] 3410 5 = 122210 3.",
    "[HEADER] 3.4 Negative numbers.",
    "Up this point, only natural (i.e., nonnegative) numbers were considered.",
    "Representing\nsigned numbers, together with positive ones, requires additional issues to be addressed,\nnamely the inclusion of a sign bit .",
    "There are many ways to represent negative num-\nbers and this section discusses four alternatives: sign-magnitude, one’s-complement, two’s-\ncomplement, and excess representations.",
    "31\n[HEADER] ESSENTIALS OF COMPUTING SYSTEMS.",
    "[HEADER] 3.4.1 Sign-magnitude.",
    "The most intuitive method, sign-magnitude , uses the MSB for the sign bit and the remaining\nbits for the magnitude of the number, i.e., its modulus or absolute value.",
    "By convention, a\n‘1’ in the sign bit indicates a negative number, whereas a ‘0’ indicates a positive number (or\nzero).",
    "In a 8-bit representation, two symmetrical values just differ in the sign bit, as next\nillustrated:\n+ 120 10 = 01111000 2\n− 120 10 = 11111000 2\nIt is mandatory to know how many bits are used to represent the numbers.",
    "The number\n1100 2 is negative if four bits are used, but positive if instead the numbers are represented\nwith six bits.",
    "In this case, extra 0s can be added to the left part of the number (001100 2 ).",
    "A disadvantage of this method is the existence of two possible representations of zero\n(“+0” and “-0”).",
    "The sign-magnitude contains the same number of positive and negative\nnumbers.",
    "A sign-magnitude integer representation with n bits ranges from − ( 2 n − 1 − 1 ) to\n+( 2 n − 1 − 1 ) .",
    "With 8 bits, this range goes from − 127 to + 127 .",
    "Signed-magnitude calculations are performed basically with the same method as hu-\nmans use with pencil and paper.",
    "As an example, consider the rules for addition:\n1.",
    "If the signs are the same, add the magnitudes and use that same sign for the result;\n2.",
    "If the signs differ, determine which operand has the larger magnitude.",
    "The sign of the re-\nsult is the same as the sign of the operand with the larger magnitude, and the magnitude\nmust be obtained by subtracting the smaller one from the larger one.",
    "[HEADER] 3.4.2 One’s-complement.",
    "Complement numeral systems were created to make additions/subtractions faster and eas-\nier.",
    "The idea is to use complementation, which is easy to apply on binary numbers.",
    "Let us analyse how this approach generally works for decimals.",
    "One decimal number can\nbe subtracted from another by adding the difference of the subtrahend from all nines and\nadding back a carry.",
    "This is called taking the nine’s complement of the subtrahend, or more\nprecisely, finding the diminished radix complement of the subtrahend.",
    "Assume that one\nwants to calculate 165 − 43 .",
    "The difference of 43 from 999 is 956 and, in nine’s complement\narithmetic, 165 − 43 = 165 + 956 = ( 1 ) 121 .",
    "The “carry” from the hundreds column is added\nback to the units place, yielding the correct result 165 − 43 = 121 + 1 = 122 .",
    "This process works similarly in the one’s complement numeral system .",
    "This system\nmakes computer arithmetic simple and has the great advantage when compared with sign-\nmagnitude that there is no need to handle sign bits separately.",
    "Anyway, one can still easily\nidentify the sign of a number by checking its MSB.",
    "The one’s-complements of binary num-\nbers is computed the same way as for natural numbers, except that the weight of the MSB\nis − 2 n − 1 + 1 instead of − 2 n − 1 .",
    "The next example shows how to compute directly the values\nof 6-bit one’s-complement numbers:\nCHAPTER 3.",
    "REPRESENTATION OF NUMBERS\n32\n011001 2 = 1 · 16 + 1 · 8 + 1 · 1\n= 25 10\n111001 2 = 1 · ( − 31 )+ 1 · 16 + 1 · 8 + 1 · 1 = − 6 10\nGiven a number V in base r having n digits, the diminished radix complement of V is\nr n − 1 − V .",
    "The range of representable integer numbers with n bits in the diminished radix\ncomplement representation is the same as for sign-magnitude one.",
    "For a binary number, its one’s complement is obtained by subtracting from all ones.",
    "For\nexample, the one’s-complement of 0101 2 is 1111 − 0101 = 1010 2 .",
    "The one’s complement of\na binary number can be obtained by just toggling all the bits (i.e., change the 1s to 0s and\nvice versa), an operation that is quite simple to implement in computer hardware.",
    "Complement notation simplifies subtraction by turning it into addition.",
    "Additionally, it\nprovides a method to represent negative numbers.",
    "The idea is that a negative number needs\nto be converted to its complement, which should have a ‘1’ in the MSB.",
    "Positive numbers,\nwhich have a ‘0’ in the MSB, are used as is, i.e., they are not converted to their complements.",
    "The next example illustrates these ideas.",
    "+ 24 10 = +( 00011000 2 ) = 00011000 2\n− 24 10 = − ( 00011000 2 )",
    "= 11100111 2\n− 10 10 = − ( 00001010 2 )",
    "= 11110101 2\nTo subtract 10 from 24 , one needs first to express the subtrahend ( 10 ) in one’s-complement\nand then add it to the minuend ( 24 ).",
    "This effectively adds − 10 to 24 .",
    "The MSB will have a ‘0’\nor a ‘1’ carry, which needs to be added to the LSB of the sum.",
    "This operation is designated\nend carry-around and results from the use of the diminished radix complement, in this case\nthe one’s-complement.",
    "The next example shows the bit operations to calculate 24 − 10 and\n10 − 24 using one’s-complement.",
    "1 ← 1 1 1\n⇐\ncarries\n0",
    "←\n1 1 1\n⇐\ncarries\n0 0 0 1 1 0 0 0\n( 24 10 )\n0 0 0 0 1 0 1 0\n( 10 10 )\n1 1 1 1 0 1 0 1\n+( − 10 10 )",
    "1 1 1 0 0 1 1 1\n+( − 24 10 )\n0 0 0 0 1 1 0 1\n1 1 1 1 0 0 0 1\n+ 1\n+ 0\n0 0 0 0 1 1 1 0\n( 14 10 )",
    "1 1 1 1 0 0 0 1\n( − 14 10 )",
    "The range of representable integer numbers with n bits is − ( 2 n − 1 − 1 ) through +( 2 n − 1 −\n1 ) .",
    "With 8 bits, this range goes from − 127 to + 127 .",
    "[HEADER] 3.4.3 Two’s-complement.",
    "Most digital computers do use the so-called two’s complement numeral system .",
    "In fact,\nthe radix complement is considered more intuitive than the diminished radix complement.",
    "Given a numeric value V in base r having n digits, the radix complement of V is defined to\nbe r n − V for V ̸ = 0 , and 0 for V = 0 .",
    "With three decimal digits, the ten’s complement of 43\nis 957 ( 10 3 − 43 ) .",
    "The decimal value for a two’s complement number is computed the same way as for a\nnatural number, except that the weight of the MSB is − 2 n − 1 instead of + 2 n − 1 .",
    "The next\nexample shows how to compute directly the values of 6-bit two’s-complement numbers:\n33\nESSENTIALS OF COMPUTING SYSTEMS\n011001 2 = 1 · 16 + 1 · 8 + 1 · 1\n= 25 10\n111001 2 = 1 · ( − 32 )+ 1 · 16 + 1 · 8 + 1 · 1 = − 7 10\nA closer analysis shows that two’s complement is just one’s complement incremented\nby 1.",
    "To find the two’s complement of a binary number, one just needs to flip bits and\nadd 1.",
    "Since the subtrahend (the number that is complemented and added) is incremented\nat the outset, there is no end carry-around to perform.",
    "Any carries involving the MSB are\nsimply discarded.",
    "Remember that only negative numbers need to be converted to two’s\ncomplement notation, as the next example illustrates:\n+ 24 10 = +( 00011000 2 )",
    "= 00011000 2\n− 24 10 = − ( 00011000 2 )",
    "= 11100111 2 + 1 = 11101000 2\n− 10 10 = − ( 00001010 2 )",
    "= 11110101 2 + 1 = 11110110 2\nThe next example shows the bit operations to calculate 24 − 10 and 10 − 24 using two’s-\ncomplement.",
    "More details about addition with two’s-complement numbers are given in\nsection 3.5 .",
    "1 ← 1 1 1\n⇐\ncarries\n0",
    "←\n1\n⇐\ncarries\n0 0 0 1 1 0 0 0\n( 24 10 )\n0 0 0 0 1 0 1 0\n( 10 10 )",
    "1 1 1 1 0 1 1 0\n+( − 10 10 )\n1 1 1 0 1 0 0 0\n+( − 24 10 )\n0 0 0 0 1 1 1 0\n( 14 10 )\n1 1 1 1 0 0 1 0\n( − 14 10 )\nThe discarded carry in the example did not cause an erroneous result.",
    "An overflow oc-\ncurs either if two positive numbers are added and the result is negative, or if two negative\nnumbers are added and the result is positive.",
    "Formally, an integer overflow occurs when\nan arithmetic operation, like an addition, tries to create a numeric value that cannot be in-\ncluded in the range of the numeral system; either greater than the maximum representable\nvalue or smaller than the minimum one.",
    "When using two’s complement notation, it is im-\npossible to have overflow whenever adding a positive number with a negative one.",
    "Two’s-complement is the preferred choice for digitally representing signed numbers,\nsince it does not require the addition and subtraction circuitry to examine the signs of the\noperands to determine whether to add or subtract.",
    "This property makes the system simpler\nto implement in hardware.",
    "Additionally, it has the best representation for 0 (all 0 bits), is\nself-inverting, and can be extended to larger numbers of bits.",
    "Finally, two’s-complement\nnumbers are added and subtracted by the same methods/algorithms as unsigned numbers\nwith the same number of bits, so the same hardware can handle numbers in both cases.",
    "Its\nbiggest drawback is the asymmetry in the range of values that can be represented, which\nmay sound non-natural.",
    "The range of representable integer numbers with n bits is − ( 2 n − 1 )\nthrough +( 2 n − 1 − 1 ) .",
    "For example, with 8 bits, this range goes from − 128 to + 127 .",
    "[HEADER] 3.4.4 Excess representations.",
    "In an excess-b representation , an n -bit pattern, whose unsigned integer value is V ( 0 ≤ V <\n2 n ) represents the signed integer V − b , where b is the bias (or offset) of the numeral system.",
    "The representable numeric values range from − b to 2 n − 1 − b .",
    "For example, with 8 bits and\nCHAPTER 3. REPRESENTATION OF NUMBERS\n34\nb = 100 , this range represents 256 different integer numbers, from − 100 to + 155 .",
    "The main\nadvantage of this digital coding scheme lies in the fact that the all-zero pattern corresponds\nto the minimal negative value and the all-one pattern to the maximal positive value.",
    "This\nfacilitates the comparison of values, since a smaller numerical values has a bit pattern\nthat is lexicographically smaller than that of a greater value.",
    "It also permits to represent\nunbalanced sets of consecutive negative and positive numbers (e.g., the subset from − 10\nto + 245 ).",
    "From a mathematical point of view, the representation of natural numbers is an\nexcess-0 representation.",
    "Often, the bias for an n -bit binary word is b = 2 n − 1 , so that the number of negative\nnumbers is the same as the number of positive numbers (including zero).",
    "With 8 bits, there\nis an excess-128 representation that includes the integer numbers from − 128 to + 127 .",
    "The most common use of excess representations is in floating-point numeral systems, as\nexplained in Section 3.6 .",
    "Table 3.2 shows, for four bits, the different numeral systems considered in this section,\nnamely two excess representations ( b = 3 and b = 7 ).",
    "binary\nun-\nsign\none’s\ntwo’s excess excess\nsigned magn.",
    "compl.",
    "compl.",
    "3\n[HEADER] 7.\n\n0000\n0\n0\n0\n0\n-3\n-7\n0001\n1\n1\n1\n1\n-2",
    "-6\n0010\n2\n2\n2\n2\n-1\n-5\n0011\n3\n3\n3\n3\n0\n-4\n0100\n4\n4\n4\n4\n1\n-3\n0101\n5\n5\n5\n5\n2\n-2\n0110\n6\n6\n6\n6\n3\n-1\n0111\n7\n7\n7\n7\n4\n0\n1000\n8\n-0\n-7\n-8\n5\n1\n1001\n9\n-1\n-6\n-7\n6\n2\n1010\n10\n-2\n-5",
    "-6\n7\n3\n1011\n11\n-3\n-4\n-5\n8\n4\n1100\n12\n-4\n-3\n-4\n9\n5\n1101\n13\n-5\n-2\n-3\n10\n6\n1110\n14\n-6\n-1\n-2\n11\n7\n1111\n15\n-7\n-0\n-1",
    "12\n[HEADER] 8.",
    "Table 3.2 Numerical values for binary numbers 0000 to 1111 in different representations.",
    "[HEADER] 3.5 Two’s-complement addition.",
    "Adding values in the two’s-complement numeral system requires the use of rules similar to\nthe ones humans use to add decimals.",
    "An important difference is that the tables for binary\nnumbers just contains 0s and 1s instead of decimal digits.",
    "Two decimal numbers are manu-\nally added, by adding each pair of digits at a time, starting with the LSDs of both numbers.",
    "If the sum is greater than 9, there is a carry that is transported to the next pair of digits\n35\nESSENTIALS OF COMPUTING SYSTEMS\n(the ones immediately to the left).",
    "When adding two binary numbers A = a n − 1 a n − 2 ... a 0 and\nB = b n − 1 b n − 2 ... b 0 , the same procedure is applied, by starting to add the LSBs a 0 and b 0 ,\nwith an initial carry c 0 equal to 0.",
    "This results in output carry bit c 1 and the sum bit s 1 .",
    "Table 3.3 shows the values of the sum s i and the output carry bit",
    "c i + 1 , for all possible\ncombinations for the inputs ( a i , b i , c i ).",
    "This process, formalised by algorithm 2 , is repeated\nfor all pairs of bits, proceeding from right to left.",
    "a i b",
    "i",
    "c",
    "i c",
    "i",
    "+ 1 s",
    "i\n0 0 0\n0\n0\n0 0 1\n0\n1\n0 1 0\n0\n1\n0 1 1\n1\n0\n1 0 0\n0\n1\n1 0 1\n1\n0\n1 1 0\n1\n0\n1 1 1\n1\n[HEADER] 1.\n\nTable 3.3 Addition of binary digits.",
    "[HEADER]",
    "Algorithm 2: addition of two binary numbers.",
    "input : Two binary numbers a and b with n digits (a n − 1 a n − 2 ... a 1 a 0 and\nb n − 1 b n − 2 ... b 1 b 0 )",
    "[HEADER] output: The sum s of the input numbers.",
    "i ← 0 ;\nc 0 ← 0 ;",
    "[HEADER] while i < n do.",
    "c i + 1 ← carry ( a i ,",
    "b i , c i ) ;\ns i ← sum (",
    "a i , b i , c i ) ;",
    "i ← i + 1 ;\n[HEADER] end.",
    "Some examples of additions of two binary numbers are next given.",
    "Notice that an addi-\ntion overflows whenever the signs of the addends are the same (both numbers are either\npositive or negative) and the sign of the sum is different from the addends’ sign.",
    "CHAPTER 3. REPRESENTATION OF NUMBERS\n36\n1\n⇐\ncarries\n0 1 0 1 1 0 1 0\n( 90 10 )\n0 0 0 1 0 1 0 0\n+( 20 10 )\n1 0 0 0 1 1 0 0\noverflow\n1\n⇐\ncarries\n1\n1 1 1\n⇐\ncarries\n0 1 0 1 1 0 1 0\n( 90 10 )",
    "1 0 1 0 0 1 1 0\n( − 90 10 )\n0 0 0 1 0 1 0 0\n+( − 20 10 )\n1 1 0 0 1 1 1 0\n+( − 50 10 )\n0 1 0 0 0 1 1 0\n( 70 10 )\n0 1 1 1 0 1 0 0",
    "[HEADER] overflow.",
    "[HEADER] 3.6 Floating-point numbers.",
    "Many numeral system assume that the radix point has a fixed position.",
    "In those cases, each\nnumber is a fixed-point number .",
    "When dealing with integers, the radix point is located\non the right (i.e., after the LSD).",
    "So with five decimal digits, the values from 0 to 99,999\ncan be represented.",
    "This system represents 100 000 ( 10 5 ) different numbers, with every\ntwo consecutive numbers differing by 1.",
    "But one can consider the radix point to be in a\ndifferent fixed position; for example, after the third decimal digit.",
    "In this case, the values\nrange from 0 to 999.99.",
    "This system also represents 100000 different numbers, but every\ntwo consecutive numbers differ by 0.01.",
    "The value of a fixed-point number is essentially an\ninteger that is scaled by an implicit specific factor determined by the position of the radix\npoint.",
    "For example, the value 0.325 can be represented as 3250 in a fixed-point numeral\nsystem with scaling factor of 1/10 000 ( 10 − 4 ), and the value 3,250,000 can be represented\nas 3250 with a scaling factor of 1000 ( 10 + 3 ).",
    "So, these two numeral systems have different\nranges, despite using the same number of decimal digits.",
    "In several calculations, this type of equally separated numbers is not useful.",
    "An alterna-\ntive is a floating-point numeral system, whose numbers have the following generic format:\nmantissa · radix exponent\nThis format is useful for performing computations involving very large numbers ( V ≫ 0 ) ,\nnumbers very close to 0 ( V ≪ 1 ) , and more generally as an approximation to real arithmetic.",
    "A floating-point number can be seen as fixed-point number, indicated by the mantissa,\nwhose radix point position is regulated by the exponent.",
    "The term floating-point is related\nto the fact that the radix point of a number can “float”, i.e., it can be placed anywhere relative\nto the significant digits of the number.",
    "This format is used in the decimal scientific notation, in which numbers are expressed in\ntwo parts: a mantissa and an exponential part that indicates an integer power of ten.",
    "The\nvalue of the number is given by the product of these two parts.",
    "So, to express 22,538 in\nthe scientific notation, one writes 2 . 2538 · 10 4 .",
    "Scientific notation simplifies any arithmetic\ncalculation that deals with very large or very small numbers.",
    "It serves also as the basis for\nfloating-point computation in digital computers.",
    "37\nESSENTIALS OF COMPUTING SYSTEMS\nIf this format is adopted again with five decimal digits, using three of them for the man-\ntissa and the other two for the exponent, then the smallest representable number is 0 · 10 0\nand the largest is 999 · 10 99 .",
    "2",
    "So, the range size in this case is 10 102 , which is much larger\nthan the fixed-point alternatives previously discussed.",
    "The larger range of the floating-\npoint numeral system is obtained at the expense of the number of significant digits that\naffect the precision of the numbers.",
    "Within a given subrange (specified by a unique ex-\nponent), there are fewer floating-point numbers than fixed-point numbers.",
    "Consider, for\nexample, the range 1000 to 1999 in the 5-digit decimal alternatives discussed here.",
    "In the\ncase of integers, exactly 1000 numbers ( 1000 , 1001 , 1002 ,... 1998 , 1999 ) are represented.",
    "With floating-point numbers, 100 numbers ( 1000 , 1010 , 1020 ,..., 1990 ) are covered, which\nare represented as 100 · 10 1 , 101 · 10 1 , 102 · 10 1 , ... 199 · 10 1 .",
    "Since computers always operate\nwith a fixed number of bits, in general, floating-point representations offer more range and\nless precision than fixed-point ones.",
    "In digital computers, floating-point numbers use bits and consist of three parts: a sign\nbit, an exponent part (representing a power of 2), and a mantissa (or significand).",
    "For illus-\ntration purposes, this section considers a 16-bit floating-point numeral system, with a 5-bit\nexponent, a 10-bit fractional part of the mantissa (so, a 11-bit mantissa as explained next),\nand a sign bit.",
    "Since both the mantissa and the exponent are signed values, both positive\nand negative numbers, as well fractions are covered.",
    "As shown in Fig.",
    "3.1 , the sign bit (s) is\nfollowed by the exponent (e), and finally by the fractional part of the mantissa (f).",
    "s\ne\n[HEADER] f.\n\nFig.",
    "3.1 Floating-point representation for 16 bits.",
    "The value encoded by a bit pattern can be divided into three different cases, depending\non the value of the exponent: normal numbers, subnormal numbers, and special values.",
    "The value of a normal number (or normalised number) is calculated by the following\nequation, based on the three bit patterns (s, e, and f).",
    "V = ( − 1 ) s × ( 1 + f )",
    "× 2 e − bias\n(3.6)\nThe sign bit s can obviously assume two possible values.",
    "If s = 0 , then ( − 1 ) s = ( − 1 ) 0",
    "=\n+ 1 , which implies that V is positive.",
    "If s = 1 , then ( − 1 ) s = ( − 1 ) 1",
    "= − 1 , implying that V is\nnegative.",
    "Notice that the other factors in Equation 3.6 are always positive.",
    "The possible values for the exponents must include both positive numbers (to repre-\nsent large numbers) and negative ones (to represent small numbers, i.e., near zero).",
    "The\nexponent e is encoded in an excess format.",
    "The bias value is a number near the middle of\nthe range of possible values that is selected to represent zero.",
    "The bias typically equals\n2 k − 1 − 1 , where k is the number of bits in the exponent.",
    "2",
    "This format is not optimised in the sense that the mantissa is not normalised.",
    "Thus, some numbers have\nmore than one representation.",
    "For instance, 2000 can be represented as 200 · 10 1 , 20 · 10 2 , and 2 · 10 3 .",
    "It also\ndoes not include negative exponents.",
    "However, it serves for discussion purposes.",
    "CHAPTER 3. REPRESENTATION OF NUMBERS\n38\nFor the 16-bit floating-point numeral system, the bias is 2 5 − 1 − 1 = 15 , which is midway\nbetween 0 and 31 .",
    "Any number larger than 15 in the exponent field represents a positive\nvalue for the real exponent.",
    "Values less than 15 indicate negative values.",
    "This is called\nan excess-15 representation, since one needs to subtract 15 to get the true value of the\nexponent.",
    "For the numeral system here discussed, the value V of a normal number is given by\nEquation 3.7 .",
    "V = ( − 1 ) s × ( 1 + f )",
    "× 2 e − 15\n(3.7)\nThis Equation only applies for exponents from 1 to 30.",
    "Exponents of all zeros ( 00000 2 =\n0 10 ) or all ones ( 11111 2 = 31 10 ) are reserved for zero, subnormal numbers, or special values,\nlike infinity, and are later described.",
    "To avoid different possible representations of the same number, the mantissa M = 1 + f\nmust be normalised.",
    "This normalisation requires the mantissa M to obey the restriction\n1 ≤ M < 2 . 3",
    "This implies that the mantissa must always start with a nonzero bit.",
    "Since the\nonly nonzero bit is ‘1’, this constant bit is hidden, as its representation is totally useless.",
    "This bit is also the only one that is to the left of the binary point.",
    "So, the only part of the\nmantissa that needs to be represented in the bit pattern is its fractional part ( f ).",
    "Since there\nare 10 bits for this part, the mantissas are 11 bits long (they all have a ‘1’ to the left of the\nbinary point).",
    "The next example shows how to represent the decimal number + 21 .",
    "5 10 in the 16-bit\nfloating-point representation:\n+ 21 .",
    "5 10 = + 10101 .",
    "1 2 = + 10101 .",
    "1 2 · 2 0 = + 1 . 01011 2 · 2 4 = + 1 . 0101100000 2 · 2 19 − 15\nThus, s = 0 (indicates non-negative numbers), e = 19 10 = 10011 2 , and f = 0101100000\n( M = 1 . 0101100000 2 ) .",
    "With these values, one can fill in the 16-bit pattern, as shown in\nFig. 3.2 .",
    "0\n0 0\n0\n0\n0 0 0 0 0\n1\n1 1\n1\n1 1\ns\ne\n[HEADER] f.\n\nFig. 3.2 16-bit floating-point representation for + 21 .",
    "5 10 .",
    "As previously indicated, Equation 3.7 does not apply for exponents 0 and 31.",
    "The all ze-\nros ( 00000 2 ) exponent is reserved to represent subnormal numbers and zero.",
    "A subnormal\nnumber (or denormalised number) is a non-zero number with magnitude smaller than the\nsmallest positive normal number.",
    "Its exponent value is fixed to be 1 − bias (-14 in the exam-\nple) and the mantissa M is restricted by the condition 0 ≤ M < 1 (there is no leading 1).",
    "So,\nfor the all-zeros e exponent, the value V of a subnormal number is given by the following\nequation:\nV = ( − 1 ) s × f",
    "× 2",
    "− 14\n(3.8)\n3",
    "In the decimal scientific notation, the values are also normalised, but in this case the mantissa M is\nrequired to be 1 ≤ M < 10 .",
    "One can generalise by stating that M must satisfy the condition 1 ≤ M <",
    "r , being\nr the base.",
    "39\nESSENTIALS OF COMPUTING SYSTEMS\nSince f can be also all-zeros ( 0000000000 2 ) , this allows V to be 0.",
    "This is very convenient\nsince the zero value, as shown in Fig. 3.3 , is represented by an all-zeros bit pattern.",
    "4 Zero\ncannot be represented by a normal number, since M ≥ 1 and the other two factors in Equa-\ntion 3.7 are never equal to zero.",
    "In fact, zero is considered a special value in a floating-point\nnumeral system.",
    "An underflow occurs when the absolute value of a number is smaller (that is, closer to\nzero) than the smallest absolute value representable in the floating-point numeral system.",
    "Underflow can theoretically be seen as negative overflow of the exponent of the floating-\npoint number.",
    "For example, if the exponent part can represent values from − 128 to + 127 ,\nthen a value with an exponent like − 150 may cause underflow.",
    "In that case, the number\ncan be represented as zero, which is the closest to the number under consideration.\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\ns\ne\n[HEADER] f.\n\nFig.",
    "3.3 16-bit floating-point representation for +0.\n\nThe all ones ( 11111 2 = 31 10 ) exponent is reserved for other special values.",
    "A special\nvalue can be used to indicate an error or to represent non-initialised data.",
    "If the fraction\nfield f is equal to all zeros, the value represents infinity ( V = − ∞ , if s = 1 ; V = + ∞ , if s = 0 ).",
    "Infinity can represent results that overflow (e.g., when multiplying two very large numbers\nor dividing by zero).",
    "When f is nonzero, the resulting value is a not a number (NaN) .",
    "Such\nvalue can be the result of an operation that cannot be given as a real number or as infinity,\ne.g., √ − 1 .",
    "Table 3.4 summarises the specific purposes for the largest and the smallest exponents\nin a floating-point numeral system, in function of the value of the mantissa.",
    "exponent M = 0\nM ̸ = 0\n000 ... 00",
    "V = ± 0 subnormal\n111 ... 11 V = ± ∞\nNaN\nTable 3.4",
    "The specific purposes for the largest and smallest exponents in a floating-point numeral system.",
    "Fig.",
    "3.4 shows for positive numbers how they are overspread, by considering for illustra-\ntion purposes the six smallest exponents ( 00000 2 to 00101 2 ).",
    "With the exception of exponent\n00000 2 (used for subnormal numbers), one can observe that the interval associated with a\ngiven exponent is larger when the exponent is bigger.",
    "In particular, the interval doubles if\nthe exponent is incremented by one unit.",
    "For example, for exponents 00100 2 and 00101 2 ,\nthe distance between two consecutive numbers is 2 − 21 and 2 − 20 , respectively.",
    "Since there\nare ten bits for the mantissa, the number of numbers represented in each interval is exactly\n4",
    "In fact, there are two representations of zero, depending on the value of the sign bit.",
    "So,\n0000000000000000 2 represents +0 and 1000000000000000 2 represents -0.\nCHAPTER 3. REPRESENTATION OF NUMBERS\n40\n1024 and they are all equally separated.",
    "This means that the distance between two con-\nsecutive numbers is larger for larger exponents.",
    "Table 3.5 shows some important values for\neach exponent.",
    "0\n2 − 14\n2 − 13\n2 − 12\n2 − 11\n2 − 10\n2 − 9\n00000\n00001\n00010\n00011\n00100\n00101\nFig.",
    "3.4",
    "The distribution of 16-bit floating-point numbers for six exponents ( 00000 2 to 00101 2 ) , indicated\nbelow the line.",
    "smallest\n2nd smallest\nlargest\nexponent\ninterval\nvalue\nvalue\nvalue",
    "[HEADER] distance.",
    "00000 2 = 0\n2 − 14\n0\n2 − 24\n1023 · 2 − 24\n2 − 24\n00001 2 = 1\n2 − 14\n2 − 14\n( 1 + 2 − 10 ) · 2 − 14 ( 1 + 1023 · 2 − 10 ) · 2 − 14\n2 − 24\n00001 2 = 1\n2 − 13\n2 − 13\n( 1 + 2 − 10 ) · 2 − 13 ( 1 + 1023 · 2 − 10 ) · 2 − 13\n2 − 23\n00011 2 = 3\n2 − 12\n2 − 12\n( 1 + 2 − 10 ) · 2 − 12 ( 1 + 1023 · 2 − 10 ) · 2 − 12\n2 − 22\n00100 2 = 4\n2 − 11\n2 − 11\n( 1 + 2 − 10 ) · 2 − 11 ( 1 + 1023 · 2 − 10 ) · 2 − 11\n2 − 21\n00101 2 = 5\n2 − 10\n2 − 10\n( 1 + 2 − 10 ) · 2 − 10 ( 1 + 1023 · 2 − 10 ) · 2 − 10\n2 − 20\n···\n11100 2 = 28\n2 + 13\n2 + 13\n( 1 + 2 − 10 ) · 2 + 13 ( 1 + 1023 · 2 − 10 ) · 2 + 13\n2 + 3\n11101 2 = 29\n2 + 14\n2 + 14\n( 1 + 2 − 10 ) · 2 + 14 ( 1 + 1023 · 2 − 10 ) · 2 + 14\n2 + 4\n11110 2 = 30\n2 + 15\n2 + 15\n( 1 + 2 − 10 ) · 2 + 15 ( 1 + 1023 · 2 − 10 ) · 2 + 15\n2 + 5\nTable 3.5 16-bit floating-point numbers for a selection of exponents.",
    "The ‘distance’ column indicates the\ndifference between two consecutive numbers for the respective exponent.",
    "The 16-bit floating-point numeral system used in this section was introduced for sim-\nplicity and conceptual understanding.",
    "It corresponds to the half precision form that is part\nof the IEEE 745 floating-point standard , originally published by the Institute of Electrical\nand Electronic Engineers (IEEE) in 1985.",
    "This standard is also used for both single- and\ndouble-precision floating-point numbers.",
    "These two formats correspond to the C float\nand double datatypes, respectively.",
    "This standard was superseded in 2008 by IEEE 754-\n2008, and again in 2019 by minor revision IEEE 754-2019.",
    "The IEEE-754 single-precision standard, represented in Fig. 3.5 (a), uses an excess 127\nbias over an 8-bit exponent.",
    "The mantissa is 23 bits.",
    "With the sign bit included, the total\nword size is 32 bits.",
    "Double-precision numbers use a signed 64-bit word consisting of an 11-\nbit exponent and 52-bit mantissa, as illustrated in Fig. 3.5 (b).",
    "The bias is 1023.",
    "The ranges\nof numbers that can be represented in the IEEE single- and double-precision models are\nshown in Table 3.6 .",
    "41\nESSENTIALS OF COMPUTING SYSTEMS\ns\ne\nf\n(a)\ns\ne\nf\nf\n(b)\nFig.",
    "3.5 IEEE 754 floating-point standard representation: (a) single-precision, (b) double-precision.",
    "single precision\ndouble precision\ndescription\ne\nf\nvalue\ndecimal\nvalue",
    "[HEADER] decimal.\n\nzero\n00..00 0..00\n0\n0.0\n0\n0.0\nsmallest subnorm. 00..00 0..01\n2 − 23 × 2 − 126\n1 . 4",
    "× 10 − 45\n2 − 52 × 2 − 1022\n4 . 9 × 10 − 324\nlargest subnorm. 00..00",
    "1..11 ( 1 − ε )",
    "× 2 − 126 1 . 2",
    "× 10 − 38 ( 1 − ε ) × 2 − 1022 2 . 2",
    "× 10 − 308\nsmallest norm.\n00..01 0..00",
    "1 × 2 − 126\n1 . 2",
    "× 10 − 38\n1 × 2 − 1022\n2 . 2",
    "× 10 − 308\none\n01..11 0..00\n1 × 2 0\n1.0\n1 × 2 0\n1.0\nlargest norm.",
    "11..10 0..00 ( 2 − ε )",
    "× 2 127\n3 . 4",
    "× 10 38\n( 2 − ε ) × 2 1023\n1 . 8 × 10 308\nTable 3.6 Representations and numeric values of some important single- and double-precision floating-\npoint numbers.",
    "[HEADER] 3.7 Binary codes for decimal numbers.",
    "As already discussed, computers use binary patterns to represent numbers, which contrasts\nwith humans that do prefer to use decimal digits.",
    "As such, some binary codes exist to facili-\ntate the process of representing decimal numbers.",
    "The representations for decimal numbers\ndo not modify the essential nature of digital circuits; they still handle signals with only two\npossible values (0 and 1).",
    "The idea is to represent a decimal number with a string of bits,\nwhere each group of contiguous bits represent one of its decimal digits.",
    "For example, if a\n4-bit string is used to represent the decimal digits, one can assign ‘0000’ to decimal digit\n0, ‘0001’ to decimal digit 1, and so on.",
    "So, a sequence of 4-bit strings represents a decimal\nnumber.",
    "For example, the sequence ‘010100001001’ represents the decimal number 509.",
    "There are 29059430400 (or 16!",
    "6! )",
    "different codes to represent the 10 decimal digits with\n4 bits (i.e., with 16 different bit patterns).",
    "The most obvious decimal code is called binary-\ncoded decimal (BCD) and encodes the decimal digits 0 to 9 by the respective 4-bit unsigned\nbinary representations 0000 through 1001.",
    "In this case, the code patterns 1010 through\n1111 are not used.",
    "This code allows one byte to store two decimal digits in a packed BCD\nrepresentation.",
    "For example, number 93 is represented by 10010011, with the first nibble\n(1001) representing decimal digit 9 and the last nibble (0011) representing decimal digit 3.",
    "Table 3.2 shows some common decimal codes.",
    "The 2421 code is a weighted code, like\nBCD that uses the weights 8421.",
    "The 2421 code has the advantage of being self comple-\nmented, that is, the code word for the 9’s-complement of any digit can be obtained by\nswapping its bits.",
    "For example, the 9’s-complement of 6 (1100) is 3 (0011).",
    "CHAPTER 3. REPRESENTATION OF NUMBERS\n[HEADER] 42.",
    "[HEADER] digit BCD 2421 2-out-of-5 biquinary 1-out-of-10.",
    "0\n0000 0000\n01100\n0100001 1000000000\n1\n0001 0001\n11000\n0100010 0100000000\n2\n0010 0010\n10100\n0100100 0010000000\n3\n0011 0011\n10010\n0101000 0001000000\n4\n0100 0100\n01010\n0110000 0000100000\n5\n0101 1011\n00110\n0100001 0000010000\n6\n0110 1100\n10001\n1000010 0000001000\n7\n0111 1101\n01001\n1000100 0000000100\n8\n1000 1110\n00101\n1001000 0000000010\n9\n1001 1111\n00011\n1010000 0000000001\nUnused bit patterns\n1010 0101\n00000\n0000000 0000000000\n1011 0110\n00001\n0000001 0000000011\n1100 0111\n00010\n0000010 0000000101\n1101 1000\n00100\n0000011 0000000110\n1110 1001\n00111\n0000100 0000000111\n1111 1010\n...\n...\n...",
    "Table 3.7 Some popular decimal codes.",
    "Decimal digits can be represented with more than four bits, which is the case for 2-\nout-of-5 representation.",
    "Each decimal digit is represented by a 5-bit pattern, in which two\nbits are set to ‘1’ and the other three to ‘0’.",
    "This type of representation is widely used by\nbarcodes and in magnetic cards.",
    "Another example is the biquinary code.",
    "The first two bits\nindicated whether the digit is in the range 0–4 or 5–9, while the last five indicate which\ndigit is represented.",
    "The use of more bits than strictly needed allows errors to be more likely\ndetected.",
    "If, for example, one bit accidentally changes due, for example, to a transmission\nerror, the resulting bit pattern does not represent a valid digit.",
    "In the biquinary code, only\n10 combinations are valid.",
    "The remaining 118 can be flagged as errors if they appear.",
    "The\n1-out-of-10 is another example of a code that uses more bits than the minimum.",
    "In this\ncase only 10 out of 1024 possible code words are valid.",
    "Only the patterns with one (and\nonly one) bit equal to ‘1’ are valid.",
    "[HEADER] Exercises.",
    "Exerc. 3.1 :",
    "As the figure shows, bank cheques in Portugal have 10 boxes to indicate the\namount to be paid.",
    "What are the minimum and the maximum values that can be written in\na bank cheque?\n43\nESSENTIALS OF COMPUTING SYSTEMS\nExerc. 3.2 :",
    "Represent the following decimal numbers as binary numbers: (a) 131 ; (b) 511 ;\n(c) 888 ; (d) 4096 .",
    "Exerc. 3.3 : What is the largest natural number that can be represented with (a) 5 , (b) 10 ,\n(c) 18 , and (d) 32 bits?\nExerc. 3.4",
    ": List all the digits and their binary representation in base 13 .",
    "Exerc. 3.5 : Convert the following binary numbers to hexadecimal: (a) 101111101101 ; (b) 1001\n110110 ; (c) 11111111111 ; (d) 10100011110 .",
    "Exerc. 3.6 : Convert the following hexadecimal numbers to binary: (a) BEEF; (b) 1000 .",
    "FF;\n(c) ABC .",
    "DEF; (d) DAC .",
    "34 .",
    "Exerc. 3.7 : Convert the following decimal numbers to base 5 : (a) 77 ; (b) 131 ; (c) 511 ; (d) 1000 .",
    "Exerc. 3.8 : Convert the following base-9 numbers to decimal: (a) 66 ; (b) 123 ; (c) 317 ; (d) 800 .\nExerc. 3.9 : Convert the following numbers from the given base to the indicated bases:\n(a) 66 10 to bases 2 , 7 and 9 ; (b) 13 F .",
    "4 16 to bases 10 and 12 ; (c) 1110010 .",
    "1 2 to bases 3 , 4 ,\nand 7 ; (d) AB 7 13 to bases 2 , 6 , and 8 .\nExerc. 3.10 :",
    "A given computer is equipped with 1,073,741,824 bytes of memory.",
    "Why was\nthis odd number chosen?\nExerc. 3.11 : The St. Galen train station, in Switzerland, is equipped with a binary electronic\nclock to indicate the time of day (hours, minutes, seconds) on three lines.",
    "At what time the\nphotograph was taken?\n(“Binary clock Swiss railway station” by BBCLCD is licensed under CC-BY-SA-4.0)\nCHAPTER 3.",
    "REPRESENTATION OF NUMBERS\n44\nExerc.",
    "3.12 : A 32-bit signed integer on a little-endian computer contains the numerical\nvalue of 3 .",
    "If it is transmitted to a big-endian computer byte by byte and stored there, with\nbyte 0 in byte 0, byte 1 in byte 1, and so on, what is its numerical value on the big-endian\nmachine if read as a 32-bit unsigned integer?\nExerc. 3.13 : As of 2018, Iceland had about 23,000 registered footballers (male and female).",
    "Calculate the minimum number of bits that allows representing this value with an integer\nencoded in signal and amplitude.\nExerc. 3.14 : Monaco had, in 2013, 37,831 inhabitants.",
    "Calculate the minimum number of\nbits that are required to encode this value as a signed integer.",
    "What is the answer if the\nvalue is encoded as an unsigned integer?\nExerc. 3.15 :",
    "A given company has 19 employees, who are paid every two weeks.",
    "It is nec-\nessary to register the number of half hours that each employee worked in each workday\n(Monday to Friday).",
    "For health reasons, the law does not permit an employee to work more\nthan 12h in a day.",
    "Indicate the minimum number of bits needed to represent this informa-\ntion for two weeks.",
    "Exerc. 3.16 : An European institute aims to assign a code to each of its members.",
    "To this\nend, it was decided to use the format AA / HHHHH-BB, with A being a capital letter, H\nbeing a hexadecimal digit and B being a base 2 digit.",
    "The two letters indicate which of the\n51 affiliated countries the member belongs to (e.g., BE for Belgium, PO for Portugal, LX for\nLuxembourg).",
    "The binary digits are used to encode the type of membership of the member\nwith the Association (00: junior member, 01: regular member, 10: senior member).",
    "Indicate,\nfor a given country, the maximum number of members that this code allows to register.",
    "Exerc. 3.17 :",
    "In 2014, the Spy’s Gangnam Style video reached 2,147,483,648 views on\nYouTube.",
    "However, the number presented was negative.",
    "Explain why this happened and\nsuggest the simplest solution to overcome it.",
    "To solve this issue, YouTube made an internal\nchange that now allows the counters to go up to 9,223,372,036,854,775,807.",
    "Describe what\napproach was followed by the YouTube engineers.",
    "Exerc. 3.18 : Find the value of X , so that: (a) 23 X = 10101 2 ; (b) 4 X 7 = 35 9 .",
    "Exerc. 3.19 : Add the following natural numbers: (a) 110011 2 + 10101 2 ; (b) 129 B 12 + 239 12 ;\n(c) CBA 16 + 987 16 .",
    "Exerc. 3.20 : Indicate the ten’s-complement of the following decimal numbers: (a) 1236 ;\n(b) 90 037 ; (c) 111 122 .",
    "Exerc.",
    "3.21 : Indicate the two’s-complement of the following binary numbers: (a) 0011100 2 ;\n(b) 1100110011 2 ; (c) 00000001 2 ; (d) 11100000001 2 .",
    "Exerc. 3.22 : Write the 8-bit sign-magnitude, one’s-complement, two’s-complement repre-\nsentations for decimal numbers: (a) + 18 ; (b) + 121 ; (c) − 33 ; (d) − 100 .",
    "Exerc. 3.23 : Calculate the value of the 10-bit binary number 10110 00111 2 in the fol-\nlowing representations: (a) sign-magnitude; (b) one’s-complement; (c) two’s-complement;\n(d) excess-511.\nExerc. 3.24 :",
    "Represent the number − 233 in the following 10-bit representations: (a) sign-\nmagnitude; (b) one’s-complement; (c) two’s-complement; (d) excess-511.",
    "Exerc. 3.25 : Perform binary subtraction by taking the two’s-complement of the subtrahend:\n(a) 100110 2 − 111 2 ; (b) 100110 2 − 10000 2 ; (c) 1010101 2 − 11 2 ; (d) 1000001 2 − 1000000 2 .\nExerc. 3.26 : Add the following pairs of unsigned binary numbers, explicitly indicating the\ncarries:\n45\n[HEADER] ESSENTIALS OF COMPUTING SYSTEMS.",
    "(a)\n11010\n(b)\n111010\n(c)\n1001111010\n(d)\n1101011\n+\n1010\n+ 101010\n+\n1011010",
    "[HEADER] + 1011000.",
    "Exerc. 3.27 : Add the following pairs of 8-bit two’s-complement numbers, explicitly indicat-\ning situations of overflow:\n(a)\n1001 1010\n(b)\n0111 1010\n(c)\n1101 1101\n(d)\n0110 1011\n+ 1000 1010\n+ 0110 1010\n+ 1110 1101\n+ 0101 1000\nExerc. 3.28 : Consider two floating-point for-\nmats F1 and F2, with 8 bits, based on all the\nprinciples presented in Section 3.6 , namely\nnormal numbers, subnormal numbers, spe-\ncial values, etc.\nF1\ns\ne\nf\nF2\ns\ne\nf\n(a) Indicate the mathematical expressions that can be used to calculate the normal num-\nbers in both formats.",
    "(b) For each format, indicate the bit patterns and the respective decimal value for i) the\nsmallest positive subnormal number, ii) the largest subnormal number, iii) the smallest\npositive normal number, iv) one, and the v) largest normal number.",
    "(c) Calculate the decimal values of the following bit patterns for the F1 format: i) 10110011 ,\nii) 01111010 , iii) 10010001 , iv) 00000011 , v) 11000001 .",
    "(d) Represent in the F1 format, the following values: i)",
    "− 111 .",
    "01 3 , ii) 128 10 , iii) 111 .",
    "01 10 ,\niv)",
    "− 18 C 16 , v) 0 .",
    "005 8 .\n(e) Convert the numbers represented in the F1 format into the F2 format: i) 00110011 ,\nii) 11101001 , iii) 00010000 , iv) 11001110 , v) 10000010 .",
    "Overflow must be represented by\n± ∞ , underflow by ± 0 and the roundings must be made to the closest value.",
    "Exerc. 3.29 : Write a C program that calculates the decimal value for a bit pattern that rep-\nresents a floating-point number.",
    "The inputs, provided through the command line, are: the\nbit pattern (sequence of non-separated 0s and 1s), the number of bits of the exponent e ,\nand the number of bits of the mantissa f .",
    "If no pattern is provided, the program lists a pair\n(bit pattern, decimal value) for all possible 2 1 + e + f bit patterns.",
    "[HEADER] Further reading.",
    "Precise and detailed analysis of the evolution of numeral systems and computer arithmetic\nis available in the seminal work by Knuth ( 1997 ).",
    "The book by Kneusel ( 2017 ) is related\nto numbers and how they are represented in and operated on by computers.",
    "It deals with\nstandard representations of integers and floating-point numbers, and presents also several\nother number representations that are useful in specific contexts.",
    "Another interesting ma-\nterial about how to represent data, most particularly numbers, in computers is provided by\nFenwick ( 2015 ).",
    "An relevant reference for floating-point numbers is the survey by Goldberg\n( 1991 ).",
    "Chapter 4\n[HEADER] IA32 instruction-set architecture.",
    "Abstract Programming in a high-level language tends to be the preferred choice for pro-\ngrammers, since the abstraction level is higher than the one provided by machine-level\nlanguages.",
    "With the level of sophistication of the current compilers, the generated code\nis usually at least as good as the one an experienced assembly-language programmer can\nmanually write.",
    "Anyhow, the ability to read and understand assembly code is important for\nprofessional programmers.",
    "This chapter presents the details of a particular assembly lan-\nguage (IA32) and discusses how high-level programs (written in C) get compiled into this\nform of machine code.",
    "Reading the assembly code generated by a compiler involves a set\nof skills that differ from the ones that are required to write assembly code by hand, since\none must understand the transformations compilers usually make in converting the con-\nstructs/statements into machine code.",
    "Comprehending assembly code and how it relates to\nthe original high-level code is the approach followed in this chapter to allow the reader to\nunderstand how computers execute programs, i.e., how they work.",
    "[HEADER] 4.1 Compilation of C code to assembly code.",
    "Programming in a high-level language, such as C, is productive and reliable, since the ab-\nstraction level is higher than the one provided by machine-level languages.",
    "When writing\nprograms in low-level code, a programmer must specify how the program manages mem-\nory and which low-level instructions the program will execute.",
    "The level of sophistication\nof the current compilers makes programming in assembly-language almost unneeded.",
    "In-\ndeed, it is very difficult for a skilled assembly-language programmer to identify parts of the\nassembly code generated by a compiler that can be optimised.",
    "Additionally, a program writ-\nten in a high-level language is portable, i.e., it can be compiled and executed on a number\nof different machines, while assembly code is specific to a reduced set of machines.",
    "Any-",
    "how, the ability to read and understand assembly code is a relevant skill for professional\nprogrammers.",
    "By invoking the compiler with appropriate flags, it generates a file showing its output\nin assembly code.",
    "Assembly code is very close to the actual ISA-level code that computers\n47\nCHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE\n48\nexecute.",
    "Its main feature is that it is in a more readable textual format, compared to the\nbinary format of object code.",
    "By reading this assembly code, the optimisation capabilities\nof the compiler and the underlying limitations of the generated code can be analysed.",
    "The ISA level has a special importance for system architects: it is the interface between\nthe software and the hardware.",
    "While it is theoretically possible to have the hardware di-\nrectly executing programs written in C, C++, Java, or some other high-level programming\nlanguages, this does not seem to be a brilliant idea.",
    "As depicted in Fig. 4.1 , the common\napproach that computer designers take is to have programs in several high-level languages\ncompiled to the ISA level and to construct microprogrammed hardware that can execute\nISA-level programs directly.",
    "The ISA level is thus the common intermediate form that es-\ntablishes the interface between the compilers and the hardware.",
    "It constitutes the language\nthat both have to understand.",
    "C program\n[HEADER] Fortran program.",
    "[HEADER] ISA level program.",
    "microprogram\nsoftware\nhardware\nexecution",
    "[HEADER] compilation.",
    "Fig.",
    "4.1",
    "The ISA level as the interface between software and hardware.",
    "In order to run a C program with a computer, the individual C statements must be trans-\nlated by other programs into a sequence of low-level machine-language instructions.",
    "These\ninstructions are packed in a form called an executable object program and stored as a binary\nfile that is saved in a disk.",
    "In the command line, the translation from source file prog.c to its corresponding object\nfile can be accomplished by invoking the gcc compiler:\n> gcc prog.c",
    "In fact, as Fig. 4.2 shows, four different programs are used to compile a C program:\npreprocessor, compiler, assembler, and linker.",
    "pre\nprocessor\ncompiler\nassembler\nlinker\nsource\nprogram\n(textual)\nmodified\nsource program\n(textual)\nassembly\nprogram\n(textual)\nrelocatable\nobject programs\n(binary)\nexecutable\nobject\n(binary)\nprog.c\nprog.i\nprog.s\nprog.o\nprintf.o\n[HEADER] prog.",
    "Fig.",
    "4.2",
    "The compilation system.",
    "In the preprocessing phase , the original C program is modified according to directives\nthat begin with the # character.",
    "For example, if an #include <stdio.h> directive is\n49\nESSENTIALS OF COMPUTING SYSTEMS\nin the C program being compiled, the preprocessor reads the contents of the header file\nstdio.h and inserts it directly into the program text.",
    "The same happens with #define\ndirectives that serve to define constants.",
    "If the program contains the #define MAX 30\ndirective, all instances of the string “MAX” are replaced by the string “30.”",
    "The preprocessor\nproduces another C program, typically with the .i suffix.",
    "The gcc compiler can be instructed to output the intermediate files that are produced,\nif the appropriate options are used.",
    "The file generated by the preprocessor can be obtained\nby invoking the gcc compiler as follows:\n> gcc -E prog.c -o prog.i\nDuring the compilation phase , the compiler translates the text file prog.i into the text\nfile prog.s , which contains an equivalent assembly-language program.",
    "Each statement\nin an assembly-language program exactly describes one low-level machine-language in-\nstruction in a standard text form.",
    "The assembly language is useful, since it constitutes a\ncommon language for compilers for different high-level languages.",
    "For example, C com-\npilers and Fortran compilers both generate output files in the same assembly language, as\nshown in Fig. 4.1 .",
    "The gcc compiler can also generate a file with the assembly code, as next indicated:\n> gcc -S prog.c -o prog.s\nIn the assembly phase , the assembler translates prog.s into machine-language instruc-\ntions, packages them in a format designated as a relocatable object program, and stores\nthe result in the object file prog.o .",
    "This file is a binary file, whose bytes encode machine\nlanguage instructions rather than characters.",
    "This file should not be open with a text editor,\nsince it does not contain textual information, but rather binary codes.",
    "To obtain the object file, gcc needs to be called with the following options:\n> gcc -c prog.c -o prog.o\nUsually, programs include other modules, like standard libraries.",
    "If the prog.c program\ncalls, for instance, the printf function, it needs to include the respective standard C library\nprovided by every C compiler ( stdio ).",
    "The printf function resides in a separate precom-\npiled object file called printf.o , which must be merged, i.e., linked, with the prog.o\nfile.",
    "So, during the linking phase , it is the responsibility of the linker to handle this merge.",
    "The result is the prog file, which is an executable.",
    "To run the prog executable, the loader is invoked.",
    "The loader is part of the operat-\ning system and is responsible for loading programs and libraries.",
    "It loads programs into\nmemory and prepares them for execution.",
    "Loading a program involves copying to the main\nmemory the machine-level instructions that are saved in its executable file.",
    "Once loading\nis complete, the operating system passes the control to the loaded program code.",
    "[HEADER] 4.2 IA32 assembly language.",
    "IA-32, the acronym for “Intel Architecture, 32-bit”, is the 32-bit version of the x86 instruction\nset architecture, developed by Intel and first implemented in the 80386 microprocessor.",
    "This\n50\nCHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE\nsection provides a non-exhaustive description of the IA32 assembly language, that is, an\noverview of the must important aspects of this machine-oriented language.",
    "These aspects\ninclude the registers, the data types, the operands for the instructions, different groups of\ninstructions (data movement, arithmetic, logical, control), the way procedures are handled,\nand how data structures are represented in IA32 .",
    "[HEADER] 4.2.1 Registers.",
    "IA32 CPUs contain eight registers, each one storing 32-bit values (Fig. 4.3 ).",
    "These registers\nare used to store numeric values as well as pointers.",
    "For the most cases, the first six registers\ncan be considered general-purpose ones, because there are no restrictions on their use.",
    "This\ngeneral nature is just broken by some instructions that implicitly use some specific registers\nas sources and/or destinations.",
    "All eight registers can be accessed as either 16 bits (word)\nor 32 bits (double word).",
    "The two low-order bytes of the first four registers can also be\naccessed independently.",
    "The last two registers (ebp and esp) contain pointers to important\nplaces in the stack.",
    "They should only be altered according to the set of standard conventions\nfor stack management.",
    "31\n16\n8 7\n0\neax\nebx\necx\nedx\nesi\nedi\nesp\nebp\nax\nbx\ncx\ndx\nsi\ndi\nsp\nbp\nah\nbh\nch\ndh\nal\nbl\ncl",
    "[HEADER] dl.\n\nFig.",
    "4.3",
    "The eight IA32 32-bit registers.",
    "As indicated in Fig.",
    "4.3 , the low-order two bytes of the first four registers can be in-\ndependently manipulated by byte-oriented instructions.",
    "This feature was provided in the\n8086, a 16-bit microprocessor, to allow backward compatibility to the 8008 and 8080, two\n8-bit microprocessors from the 1970 decade.",
    "Whenever a byte instruction updates one of\nthese single-byte registers, the remaining three bytes of the full register remain unchanged.",
    "Similarly, the low-order 16 bits of each register can be read or written by word-oriented in-\n51\nESSENTIALS OF COMPUTING SYSTEMS\nstructions.",
    "This characteristic results from the fact that IA32 inherits many features of all\nits predecessors, namely 16-bit microprocessors.",
    "Another important register is the instruction pointer, referred to as eip in IA32.",
    "As already\nindicated, its purpose is to indicate the address in memory of the next instruction to be\nexecuted.",
    "[HEADER] 4.2.2 Data types.",
    "Due to IA32 being an expansion from a 16-bit architecture, Intel uses the term “word” to\nrefer to a 16-bit data type.",
    "Based on this, 32-bit quantities are referred to as “double words.”",
    "Table 4.1 shows the machine representations used for the primitive data-types of C. Note\nthat most of the common datatypes are stored as double words.",
    "This includes both regular\nand long integers (types int and long ), whether or not they are signed.",
    "Additionally, all\npointers (shown here as char *) are stored as 4-byte double words.",
    "Bytes are commonly\nused when manipulating string data (i.e., ASCII characters).",
    "As the table indicates, every\noperation has a single-character suffix denoting the size of the operand.",
    "For example, the\nMOV (move data) instruction has three variants: MOVB (move byte), MOVW (move word), and\nMOVL (move long/double word).",
    "The assembly code discussed here follows the syntax followed by the GNU assembler\n(known as GAS).",
    "There exist some smaller differences with the assembler provided by Intel.",
    "Anyhow, it should not be difficult to spot those differences which are usually small.",
    "C datatype",
    "[HEADER]",
    "Intel datatype GAS suffix size (bytes).",
    "char\nByte\nb\n1\nshort\nWord\nw\n2\nint\nDouble word\nl\n4\nunsigned\nDouble word\nl\n4\nlong int\nDouble word\nl\n4\nunsigned long Double word\nl\n4\nchar *\nDouble word\nl\n[HEADER] 4.",
    "Table 4.1 Sizes of standard datatypes.",
    "[HEADER] 4.2.3 Operands.",
    "Many instructions have operands, which are used to specify the source values for performing\nthe operation and the destination location into which to store the result.",
    "IA32 supports\na different number of operand forms, as indicated in Table 4.2 , where Imm represents a\nconstant, R x the contents of a register, s a scale (1, 2, 4 or 8), and M [ addr ] the contents of\nthe memory in the location whose address is given by addr .",
    "CHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE",
    "[HEADER] 52.\n\ntype\nform\noperand value",
    "[HEADER] name.",
    "immediate $Imm\nImm\nconstant\nregister\n%R a\nR a\nregister\nmemory\nImm\nM [ Imm ]\nabsolute\n(%R b )\nM [ R b ]]\nindirect\nImm(%R b )\nM [ R b + Imm ]\nbase+offset\n(%R b ,%R i )\nM [ R b + R i ]\nindexed\nImm(%R b ,%R i )",
    "M [ R b + R i + Imm ]\nindexed\n(,%R i ,s)\nM [ R i · s ]\nscale indexed\nImm(,%R",
    "i ,s)\nM [ R i · s + Imm ]\nscale indexed\n(%R b ,%R i ,s)\nM [ R b + R i · s ]\nscale indexed\n[HEADER] Imm(%R b ,%R i ,s) M [ R b + R i · s + Imm ] scale indexed.",
    "Table 4.2 Operands forms.",
    "Basically, there are three major forms for the operands:\n• Immediate is used to constant values, which can only be used as sources.",
    "Constants are\nwritten with a ‘$’ followed by an integer using standard C notation, such as, $-577 or\n$0x1F .",
    "•",
    "Register is used to denote the contents of one of the registers, either with 32 bits (e.g.,\neax), 16 bits (e.g., ax), or 8 bits (e.g., ah).",
    "A register is specified with a leading ‘%’ followed\nby its name.",
    "The notation R a identifies register a and represents its contents.",
    "•",
    "Memory is used to memory locations, according to an address that is calculated.",
    "Since\nthe memory is viewed as a large array of bytes, the notation M [ addr ] is used to note\na reference to the value stored in memory starting at address addr .",
    "There are exactly\nnine different addressing modes to access memory.",
    "The most generic form is the last\none in Table 4.2 : Imm(R b ,R i ,s).",
    "It has four components: an immediate offset (Imm), a base\nregister (R b ), an index register (R i ), and a scale factor (s), whose value must be 1, 2, 4, or 8.",
    "The effective address is then computed as R b + R i · s + Imm .",
    "This general form facilitates\nthe access to array elements.",
    "The other forms are simply special cases of this generic\nform, where some of the components are omitted.",
    "The omitted elements are assumed\nto have a zero value, but s that has 1 has its default value.",
    "Generically, source values can be given as constants or read from registers or memory.",
    "Destination values can be written in either registers or memory.",
    "[HEADER] 4.2.4 Data movement instructions.",
    "Moving data is a fundamental operation in a computer.",
    "The term “move” must be seen\nas a synonym of “copy,” since the values in the source remain there unchanged.",
    "Table 4.3\nshows some IA32 instructions to move data, where s and d represent source and destination\noperands.",
    "Since IA32 has a maximum of two operands per instruction, in many cases, the\ndestination operand also acts a source operand.",
    "53\n[HEADER] ESSENTIALS OF COMPUTING SYSTEMS.",
    "instruction\neffect\n[HEADER] description.",
    "MOV s, d\nd ← s\nmove\nmovb\nmove byte\nmovw\nmove word\nmovl\nmove double-word\nMOVZ s, d",
    "d ← zeroExt",
    "( s )\nzero-extending move\nmovzbw\nmove zero-extended byte to word\nmovzbl\nmove zero-extended byte to double-word\nmovzwl\nmove zero-extended word to long\nMOVS s, d",
    "d ← signExt ( s )\nsign-extending move\nmovsbw\nmove sign-extended byte to word\nmovsbl\nmove sign-extended byte to double-word\nmovswl\nmove sign-extended word to long\nPUSH s\nesp ← esp − size ( s ) push\npushl\nM [ esp ] ← s\npush double-word\npushw\npush word\nPOP d\nd ← M [ esp ]\npop\npopl\nesp ← esp + size ( s ) pop double-word\npopw\n[HEADER] pop word.",
    "Table 4.3 IA32 instructions for moving data.",
    "Many IA32 instructions have three variants: one for bytes, one for words, and a third one\nfor double-words.",
    "This occurs for the MOV instruction, whose variants ( movb , movw , and\nmovl ) are differentiated by the last character (b, w, or l).",
    "The source operand s designates a\nvalue that is immediate, stored in a register, or stored in memory.",
    "The destination operand\nd designates a location that is either a register or a memory address.",
    "It is not possible for\na MOV instruction to have both operands refer to memory locations.",
    "Thus, copying a value\nfrom one memory location to another one can be achieved with two instructions: the first\none loads the source value into a register, and the second writes the register value to the\ndestination.",
    "The next examples illustrate the five possible combinations of sources and\ndestinations, with the movl instructions that handles operands with 32 bits:\nmovl $0x40, %eax\nImmediate–Register\nmovl %ebp, %esp\nRegister–Register\nmovl (%edi,%ecx), %edx\nMemory–Register\nmovl $-15, (%esp,%eacx)\nImmediate–Memory\nmovl %ebx, -12(%ebp)",
    "Register–Memory\nTo move data with the size of one or two bytes, IA32 provides the instructions movb and\nmovw , respectively.",
    "When the operands are registers, they should have the adequate sizes.",
    "movb $0x40, %bl\nImmediate 8 bits\nmovw $0x40, %ax\nImmediate 16 bits\nmovb (%edi,%ecx), %dh\nMemory–Register\nmovw $-15, (%esp,%eacx)\nImmediate–Memory\nmovw %bx, -12(%ebp)",
    "Register–Memory\nThe suffixes b, w and l are not strictly necessary, when registers are involved, since they\nhave well-know sizes.",
    "This does not occur for Immediate-Memory moves, since the sizes\nmay not be evident.",
    "CHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE\n54\nThe MOVZ and MOVS instructions both read the contents of the register or effective ad-\ndress as a word or byte and then extends to word or double-word.",
    "MOVZ adds zero’s to the\nMSBs of the destination.",
    "It serves to convert an unsigned integer to a wider unsigned in-\nteger.",
    "MOVS extends the sign bit of the source to the MSBs of the destination, so it can be\nused to convert a signed integer to a wider signed integer.",
    "In both cases, the result is stored\nin the destination register.",
    "Consider that al=00 16 , bl=81 16 and cx=FFFF 16 .",
    "Note that the MSBs of al, bl, and cx are 0,\n1, and 1, respectively.",
    "The next examples show, in the right part of each line, the values that\nare stored in the destination registers when the corresponding instructions are executed:\nmovzbw %al, %dx\ndx\n= 0000 16\nmovsbw",
    "%al, %dx\ndx\n= 0000 16\nmovzbw %",
    "bl, %dx\ndx\n= 00",
    "81 16\nmovsbw %bl, %dx\ndx\n= FF81 16\nmovzbl %",
    "bl, %edx\nedx = 000000 81 16\nmovsbl %bl, %edx\nedx = FFFFFF81 16\nmovzwl %cx, %edx\nedx = 0000 FFFF 16\nmovswl %cx, %edx\nedx = FFFFFFFF 16\nThe IA32 programming model also provides a stack , where temporary data can be stored.",
    "This stack is stored in some region of the main memory.",
    "It is accessed through the instruc-\ntions pushl and popl .",
    "1",
    "These two instructions manipulate a single four-byte operand,\neither the data source for pushing or the data destination for popping.",
    "The stack grows\ndownward such that the top element of the stack has the lowest address of all stack ele-\nments.",
    "Stacks are illustrated with the stack “top” shown at the top of the figures.",
    "The stack\npointer esp holds the memory address of the top stack element.",
    "Popping a double word includes reading from the top of the stack location and then\nincrementing the stack pointer by four.",
    "Thus, the instruction popl %ecx is functionally\nequivalent to the following pair of instructions:\nmovl (%esp), %cx\naddl $4, %esp\nPushing a double-word value onto the stack involves first decrementing the stack pointer\nby four and then writing the value at the address of the new top of the stack.",
    "Therefore, the\nbehaviour of the instruction pushl %edx is exactly the same as the one produced by the\nfollowing instructions:\nsubl $4, %esp\nmovl %edx, (%esp)\nFig.",
    "4.4 illustrates how the stack works.",
    "This example assumes that initially the contents\nof the stack and the relevant registers are as indicated in Fig.",
    "4.4 (a).",
    "When the instruction\npopl %ecx is executed, the contents of the memory in the address given by register esp\n(2108 16 ) is copied to register ecx.",
    "Additionally, the value in register esp is incremented by\nfour, yielding 210C 16 .",
    "As indicated previously, information in processors is not moved but\n1 IA32 also provides instructions to use the stack with words ( pushw and popw ), but they are not dis-\ncussed in this book.",
    "The stack, being in the memory, can also be accessed with other instructions, like MOV\ninstructions.",
    "55\nESSENTIALS OF COMPUTING SYSTEMS\nrather copied, so the value 1234 16 remains at memory location 2108 16 , until it is eventually\noverwritten by another push operation.",
    "The top of the stack however is always considered\nto be the address indicated by esp.",
    "The result of the execution of this popl instruction is\nshown in Fig.",
    "4.4 (b).",
    "Now, the instruction to be executed is pushl %edx .",
    "Firstly, the value in register esp is\ndecremented by four, yielding 2108 16 .",
    "The contents of register edx is copied to the memory\nin the address given by esp.",
    "Again, the move operation does not remove or delete the value\nthat is stored in register edx; it was just copied to the destination.",
    "Fig. 4.4 (c) shows the\nresult of executing this pushl instruction.\necx\nedx\nesp\n...\n...\n...\n...\n...",
    "ecx\nedx\nesp\n...",
    "...\n...\n...\n...\necx\nedx\nesp\n...",
    "...\n...\n...\n...\n1234\n1234\n3D98\n2100\n2104\n2108\n210C\n2110\n2114\n2100\n2104\n2108\n210C\n2110\n2114\n0\n1234\n1234\n3D98\n3D98\n3D98\n2108\n210C\n2108\n(a)\n(b)\n(c)\nFig.",
    "4.4",
    "A stack: (a) initial state; (b) state after executing popl %ecx ; (c) state after executing pushl\n%edx .",
    "The values in the registers and that indicate memory addresses are represented in hexadecimal.",
    "The fact that the stack is contained in the memory allows programs to access arbitrary\npositions within the stack, using the standard memory addressing mechanisms.",
    "For exam-\nple, the instruction movl 8(%esp),%ebx copies to register ebx the third double word\nfrom the top of the stack.",
    "[HEADER] 4.2.5 Arithmetic and logical instructions.",
    "A computer must obviously be able to perform arithmetical and logical operations.",
    "Table 4.4\nlists the most used IA32 instructions of this type.",
    "The LEAL instruction has the same form of a memory-register MOV instruction, but it\ndoes not reference memory at all.",
    "The first operand, i.e., the source, indicates a memory\nreference, but instead of reading from the designated location, the instruction copies its\neffective address to the destination.",
    "This computation is indicated in Table 4.4 with the\naddress() function (equivalent to the address/pointer operator & in the C language).",
    "The single-operand form of the IMUL instruction executes a signed multiply of a byte,\nword, or double-word by the contents of the al, ax, or eax registers and stores the prod-\nuct in the ax, dx:ax or edx:eax registers, respectively.",
    "The two-operand form of IMUL ex-\necutes a signed multiply of a register or memory word or double-word by a register word\nor double-word and stores the product in that register word or long word.",
    "There is also\nCHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE",
    "[HEADER] 56.\n\ninstruction\neffect\n[HEADER] description.",
    "LEAL s, d",
    "d ← address ( s ) load effective address\nADD s, d\nd ← d + s\nadd\naddb\nadd bytes\naddw\nadd words\naddl\nadd double-words\nINC d\nd ← d + 1\nincrement\nincb\nincrement byte\nincw\nincrement word\nincl\nincrement double-word\nSUB s, d\nd ← d",
    "− s\nsubtract\nsubb\nsubtract bytes\nsubw\nsubtract words\nsubl\nsubtract double-words\nDEC d\nd ←",
    "d",
    "− 1\ndecrement\ndecb\ndecrement byte\ndecw\ndecrement word\ndecl\ndecrement double-word\nNEG d\nd ←−",
    "d\ntwo’s-complement\nnegb\ntwo’s-complement byte\nnegw\ntwo’s-complement word\nnegl\ntwo’s-complement double-word\nNOT d\nd ← ˜ d\none’s-complement\nnotb\none’s-complement byte\nnotw\none’s-complement word\nnotl\none’s-complement double-word\nIMUL s, d",
    "d ←",
    "d",
    "× s\nsigned multiply\nimulb\nsigned multiply bytes\nimulw\nsigned multiply words\nimull\nsigned multiply double-words\nIMUL d",
    "d ←",
    "d",
    "× R a\nmultiply\nimulb\nsigned multiply bytes\nimulw\nsigned multiply words\nimull\nsigned multiply double-words\nIDIV s\nR d :",
    "R a ← R a / s signed division\nidivb\nR a ← R b % s\nsigned division bytes\nidivw\nsigned division words\nidivl\nsigned division double-words\nSAR n, d\nd ← d ≫ n\narithmetic right shift\nsarb\narithmetic right shift byte\nsarw\narithmetic right shift word\nsarl\narithmetic right shift double-word\nSAL n, d\nd ← d ≪ n\narithmetic left shift\nsalb\narithmetic left shift byte\nsalw\narithmetic left shift word\nsall",
    "[HEADER] arithmetic left shift double-word.",
    "Table 4.4 IA32 instructions for arithmetically operating the data.",
    "57\nESSENTIALS OF COMPUTING SYSTEMS\na three-operand instruction that executes a signed multiply of a 16- or 32-bit immediate\nby a register or memory word or long and stores the product in a specified register word\nor long.",
    "The instruction MUL works in the same way as IMUL but executes an unsigned\nmultiplication.",
    "To better explain how these instructions operate, consider the following examples:\nimulb 5(%edi)",
    "mulw 8(%edi), %dx\nimull $12345678, 4(%edi), %eax\nThe imulb instruction performs an 8-bit signed multiply of the al register and the byte\nstored in the memory address given by the esi register plus an offset of 5.",
    "The result goes\ninto register ax.",
    "The mulw instruction executes a 16-bit unsigned multiply of the contents\nin the memory addressed given by the edi register plus an offset of 4 and the contents of the\nedx register.",
    "The result is stored in this register.",
    "Finally, the imull instruction calculates\nthe signed product between the 32-bit constant 12345678 and the double-word contents\nin the memory address given by the edi register plus an offset of 4.",
    "The result is stored in\nthe eax register.",
    "IDIV executes signed division.",
    "It divides a 16-, 32-, or 64-bit register value (dividend)\nby a register or memory byte, word, or long (divisor).",
    "The size of the divisor implies the\nspecific registers used as the dividend, quotient, and remainder, as indicated in Table 4.5 .",
    "If\nthe resulting quotient is too large to fit in the destination, or if the divisor is 0, an interrupt\n0 is generated.",
    "Non-integral quotients are truncated toward 0.",
    "The remainder has the same\nsign as the dividend; the absolute value of the remainder is always less than the absolute\nvalue of the divisor.",
    "The instruction DIV works in the same way as IDIV but executes an\nunsigned division.",
    "[HEADER] divisor size dividend quotient remainder.",
    "byte\nax\nal\nah\nword\ndx:ax\nax\ndx\ndouble\nedx:eax\neax",
    "[HEADER] edx.",
    "Table 4.5 Register implicitly involved in the IDIV and DIV instructions.",
    "SAL left shifts (multiplies) the operand for a count and stores the product in that operand.",
    "The MSB is shifted into the carry flag; the low-order bit is cleared.",
    "The instruction SAR right\nshifts (signed divides) the operand for a count, leaving the MSB unchanged.",
    "In both cases,\nthe shift count is specified by an immediate value or by the contents of register ecl. Fig.",
    "4.5\nillustrates these two arithmetic shift operations, considering their 8-bit versions.",
    "Table 4.6 lists the most used IA32 instructions to perform logical operations.",
    "The AND , OR , and XOR instructions perform, respectively, an AND, OR, and exclusive OR\nof each bit in the values specified by the two operands and stores the result in the second\noperand.",
    "Fig.",
    "4.6 exemplifies the effects of these three instructions.",
    "SHL is the same operation of SAL .",
    "They are synonymous mnemonics.",
    "SHR right shifts\n(unsigned divides) the operand for a count.",
    "It sets the MSB to 0.",
    "The shift count is specified\nCHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE\n58\n0\n1\n0\n1\n0\n0\n1\n1\n0\n1\n0\n1\n0\n0\n1\n[HEADER] 1.\n\n1\n0\n1\n0\n0\n1\n1\n0\n0\n0\n1\n0\n1\n0\n0\n[HEADER] 1.\n\nCF\nCF\n1\n0\nsalb 1, %al\nsarb 1, %bl\nbefore\nafter\nal\nbl\n(a)",
    "[HEADER] (b).",
    "Fig. 4.5",
    "The arithmetic shift instructions.",
    "instruction effect",
    "[HEADER] description.",
    "AND s, d",
    "d ← d & s\nbitwise AND\nandb\nbitwise logical AND bytes\nandw\nbitwise logical AND words\nandl\nbitwise logical AND double-words\nOR s, d\nd ← d",
    "| s\nbitwise OR\norb\nbitwise logical OR bytes\norw\nbitwise logical OR words\norl\nbitwise logical OR double-words\nXOR s, d",
    "d ←",
    "d",
    "ˆ s\nbitwise logical exclusive OR\nxorb\nbitwise logical exclusive OR bytes\nxorw\nbitwise logical exclusive OR words\nxorl\nbitwise logical exclusive OR double-words\nSHR n, d d ← d ≫ n\nlogical right shift\nshrb\nlogical right shift byte\nshrw\nlogical right shift word\nshrl\nlogical right shift double-word\nSHL n, d same as SAL\nlogical left shift\nshlb\n(see Table 4.4 ) logical left shift byte\nshlw\nlogical left shift word\nshll\n[HEADER] logical left shift double-word.",
    "Table 4.6 The IA32 instructions for logically operating the data.",
    "0\n1\n0\n1\n0\n1\n0\n1\n0\n0\n0\n0\n1\n1\n1\n1\n0\n1\n0\n1\n0\n1\n0\n1\n0\n0\n0\n0\n1\n1\n1\n1\n0\n1\n0\n1\n0\n1\n0\n1\n0\n0\n0\n0\n1\n1\n1\n1\n0\n0\n0\n0\n0\n1\n0\n1\n0\n1\n0\n1\n1\n1\n1\n1\n0\n1\n0\n1\n1\n0\n1\n0\nal\nbl\nresult\nandb %",
    "bl, %al\norb %bl, %al\nxorb",
    "%bl, %al\n(a)\n(b)",
    "[HEADER] (c).",
    "Fig.",
    "4.6",
    "The logical instructions.",
    "59\nESSENTIALS OF COMPUTING SYSTEMS\nby an immediate value or by the contents of register ecl. Fig.",
    "4.7 illustrates the logical right\nshift operation, considering its 8-bit version.",
    "0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n1\n0\n1\n0\n0\n1\nshrb 1, %al\nbefore\nafter\n[HEADER] al.\n\nFig.",
    "4.7",
    "The shift right logic instruction.",
    "[HEADER] 4.2.6 Control instructions.",
    "As already indicated, the biggest difference between a computer and a simple calculator is\nthe ability of the former to make decisions and to use data whose values depend on data.",
    "This allows different instructions to be executed, based on the values computed during\nthe program (i.e., not known in compile time).",
    "By default, the machine-level instructions\nare executed in sequence, i.e., according to the order in which they appear in the pro-\ngram.",
    "In some points, it is however necessary to break this default rule.",
    "This happens in\nconstructs available in high-level programming languages like IF-THEN-ELSE , SWITCH ,\nFOR , REPEAT-UNTIL , and DO-WHILE and function/procedure calls.",
    "IA32 includes various instructions that are relevant to control the flow of execution, or\nseen from a different perspective to support those high-level constructs.",
    "Usually, the flow\nof control is dependent on a given condition, that is, on the values of some variables.",
    "If\nthat condition is true, the program jumps to an instruction that is not the next one, thus\nbreaking the default behaviour.",
    "Otherwise, the next instruction is executed.",
    "A condition code , also known as status flag, is the mechanism used by processors to save\na specific attribute related to the last arithmetic or logic operation.",
    "By testing a set of these\nflags, conditional jumps to specific locations into the code can be performed.",
    "IA32 provides\nthe following condition codes:\nCF (carry flag) :",
    "The most recent operation generated a carry out of the most significant\nbit.",
    "This flag is used to detect overflow for unsigned operations.",
    "OF (overflow flag) :",
    "The most recent operation caused a two’s-complement overflow, ei-\nther negative or positive.",
    "SF (sign flag) :",
    "The most recent operation yielded a negative value.",
    "ZF (zero flag) :",
    "The most recent operation yielded zero.",
    "Table 4.7 shows some of the most used IA32 instructions to test data.",
    "The CMP instruction compares the two source operands, by subtracting the second\noperand from the first one, and sets the status flags according to the results.",
    "It does not\nalter either of the operands and can be used to determine if the second operand is greater\nCHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE",
    "[HEADER] 60.\n\ninstruction",
    "[HEADER] effect description.",
    "CMP s2,s1\ns 1 − s 2 compare\ncmpb\ncompare bytes\ncmpw\ncompare words\ncmpl\ncompare double-words\nTEST s2,s1 s 1 & s 2 test\ntestb\ntest bytes\ntestw\ntest words\ntestl",
    "[HEADER] test double-words.",
    "Table 4.7",
    "The IA32 instructions for tests.\n\nthan, equal to, or less than the first operand.",
    "The TST instruction performs a bit-wise logical\nAND of the two operands.",
    "The result of a logical AND is 1 if the value of both operands is\n1; otherwise, the result is 0.",
    "This instruction clears the OF and CF flags, and sets the SF, ZF\nand PF flags, according to the result.",
    "Each SET instruction sets the destination (a single byte) to either 0 or 1 based on some\ncombination of the condition codes.",
    "Some instructions have “synonyms,” that is, alternate\nmnemonics for the same machine instruction, as indicated in Table 4.8 .",
    "instruction synonyms effect",
    "[HEADER] set condition.",
    "sete d\nsetz\nd",
    "← ZF\nEqual / zero ( = 0 )\nsetne d\nsetnz\nd ← ˜ ZF\nNot equal / not zero ( ̸ = 0 )\nsets d\nd ← SF\nNegative ( < 0 )",
    "setns d\nd",
    "← ˜ SF\nNonnegative ( ≥ 0 )\nsetg d\nsetnle\nd ← ˜ ( SF ˆ OF ) & ˜ ZF Greater (signed > )\nsetge d\nsetnl\nd ← ˜ ( SF ˆ OF )\nGreater or equal (signed ≥ )\nsetl d\nsetnge\nd ← SF ˆ OF\nLess (signed < )",
    "setle d\nsetng\nd ← ( SF ˆ OF )",
    "| ZF\nLess or equal (signed ≤ )",
    "seta d\nsetnbe\nd ← ˜ CF & ˜ ZF\nAbove (unsigned > )\nsetae d\nsetnb\nd ← ˜ CF\nAbove or equal (unsigned ≥ )\nsetb d\nsetnae\nd ← CF\nBelow (unsigned < )",
    "setbe d\nsetna\nd ← CF | ZF\n[HEADER] Below or equal (unsigned ≤ ).",
    "Table 4.8 The IA32 SET instructions.",
    "By default, instructions follow each other in the exact order they are listed in the pro-\ngram.",
    "IA32 provides instructions to break this normal (i.e., sequential) flow of execution\n(Table 4.9 ), allowing the program to “jump” to an instruction that is different from the next\none.",
    "These jump destinations are generally indicated in assembly code by a label.",
    "They ef-\nfectively jump to the destination, if a given condition does hold.",
    "Otherwise, the jump is not\nexecuted and the program continues as usual, i.e., with the next instruction.",
    "Some jump\ninstructions have “synonyms” (alternate names for the same machine instruction).",
    "The next example shows a piece of C code with an IF-THEN-ELSE construct and a\nbehaviourally-equivalent piece of assembly code, which includes two jump instructions\njne and jmp .",
    "61\n[HEADER] ESSENTIALS OF COMPUTING SYSTEMS.",
    "instruction synonyms condition\n[HEADER] description.",
    "jmp l\nDirect jump\njmp *o\nIndirect jump\nje l\njz\nZF\nEqual / zero ( = 0 )\njne l\njnz\n˜ ZF\nNot equal / not zero ( ̸ = 0 )",
    "js l\nSF\nNegative ( < 0 )\njns l\n˜ SF\nNonnegative ( ≥ 0 )",
    "jg l\njnle\n˜ ( SF ˆ OF ) & ˜ ZF Greater (signed > )\njge l\njnl\n˜ ( SF ˆ OF )\nGreater or equal (signed ≥ )\njl l\njnge\nSF ˆ OF\nLess (signed < )\njle l\njng\n( SF ˆ OF ) | ZF\nLess or equal (signed ≤ )",
    "ja l\njnbe\n˜ CF & ˜ ZF\nAbove (unsigned > )\njae l\njnb jnc ˜ CF\nAbove or equal (unsigned ≥ )\njb l\njnae jc CF\nBelow (unsigned < )",
    "jbe l\njna\nCF | ZF\n[HEADER] Below or equal (unsigned ≤ ).",
    "Table 4.9",
    "The IA32 JUMP instructions.",
    "if (a==b)\ncmpl %eax, %bx\nc+=3;\njne .lb2\nelse\n.lb1:",
    "addl $3, %ecx\nc++;\njmp .lb3\n.lb2:",
    "addl $1, %ecx\n.lb3: ...",
    "The example assumes that variables a , b , and c are saved in registers eax, ebx, and\necx, respectively.",
    "The instruction jmp .lb3 causes the program to skip over the instruction\nlabeled .lb2 and instead to continue execution with the instruction labelled by .lb3 .",
    "This\nin an unconditional jump, as it is always performed and does not depend on the evaluation\nof a given condition.",
    "The jne .lb2 instruction is a conditional jump that depends on the\nZF flag, that was set by the cmpl instruction.",
    "If the ZF = 1 , the program jumps to the\ninstruction labelled by .lb2 .",
    "Otherwise (i.e., if ZF = 0 ), the jump does not occur and the\nprogram flows as usual, executing the next instruction, which in this case is the one labeled\nby .lb1 .",
    "A label constitutes a human convenience and is represented by a symbolic name (string)\nfollowed by a colon (:).",
    "Whenever the assembler encounters a new label, it calculates its\nmemory address and saves that information in an auxiliary data structure.",
    "When the object-\ncode is generated, the assembler uses that data and encodes the jump targets (the addresses\nof the destination instructions) as part of the jump instructions.",
    "Direct jumps are written in assembly code by giving a label as the jump target, for ex-\nample, the label .lb1",
    "in the example considered previously.",
    "Indirect jumps are specified\nwith a ‘*’ followed by an operand specifier which can be a register or a memory operand\nwith any of the formats listed in Table 4.2 .",
    "For instance, the instruction\njmp *%eax\nuses the value in register eax as the jump target, and the instruction\njmp *4(%eax)\nCHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE\n62\nreads the jump target from memory, using as the read address the sum of the value in eax\nwith 4.",
    "The typical control flow constructs available in high-level languages, like FOR , WHILE-DO ,\nDO-WHILE , REPEAT-UNTIL , and SWITCH , can be reproduced.",
    "The next example shows\na WHILE-DO loop in C code and its possible translation into assembly code.",
    "Variable a is\nsaved in register eax.",
    "while (a<50) {\n.lb1: cmpl $50, %eax\n...",
    "jge .lb2\na++;\n...\n}\nincl %eax\njmp .lb1\n.lb2: ...",
    "Assembly code for DO-WHILE loops can be made more efficient than for WHILE loops,\nsince they only require one jump instruction (and not two), as next exemplified:",
    "do {\n.lb1: ...\n...\nincl %eax\na++;\ncmpl $50, %eax\n} while (a < 50)\njl .lb1\n.lb2: ...",
    "It is relevant to present how the jumps are coded at the machine level.",
    "IA32 uses two ma-\njor encodings for jumps.",
    "In an absolute jump , the instruction directly indicates the location\nin the memory to where the program jumps (i.e., the value to be directly copied to register\neip).",
    "In IA32, this location occupies four bytes.",
    "In a relative jump , the value indicated in\nthe instruction is a signed offset that is added to the address of the instruction following\nthe jump instruction to calculate the destination.",
    "This offset value can be 8-bit, 16-bit, or\n32-bit long.",
    "The use of the address of the next instruction (and not the one of the jump in-\nstruction) results from the fact that the processor updates the instruction pointer as one of\nthe first steps in executing an instruction.",
    "At the machine level, two assembly instructions\nwith the same mnemonics can correspond to different machine level instructions (with dif-\nferent opcodes).",
    "This should be not seen as a surprise, since the opcode is used to identify\nthe instruction, but also other elements, namely the number and the type of operands.",
    "The\nnext example show the representations of two jg instructions at the machine-level (bytes\nare represented with two hexadecimal digits):",
    "jg .lb1\n7F 0C\njg .lb2",
    "0F 8F 02 01 00 00",
    "The first jg instruction (opcode 7F) uses just one byte to indicate the offset, while the\nsecond one (opcode 0F) uses four bytes, which are the last ones (00 00 01 02, according to\nthe little endian order).",
    "The assembler and the linker select whether a jump uses relative or\nabsolute destinations.",
    "The next example exemplify how relative jumps work at the machine\nlevel.",
    "movl %edi, %eax\n0: 89 C7\njmp .lb1\n2: EB 01\n.lb2: decl %eax\n4: 48\n63\nESSENTIALS OF COMPUTING SYSTEMS\n.lb1:",
    "testl",
    "%eax, 400(%esi)\n5: 85 46 90 01 00 00\njg .lb2\nB: 7F F7\nincl %ebx\nD: 43",
    "In each line, one sees an assembly instruction, the relative address (in decimal), and its\nmachine-level representation (in hexadecimal).",
    "The movl instruction is located in relative\naddress 0 and occupies two bytes (89 16 and C7 16 ).",
    "The jmp instruction is located in relative\naddress 2 and also occupies two bytes (EB 16 and 01 16 ).",
    "The last byte indicates the offset\nfor the jump, which in this case is +1.",
    "It is calculated as the offset that must be added\nto the relative address of the next instruction ( decl ) to reach the destination (relative\naddress of the instruction in label .lb1 ).",
    "For the jg instruction the offset is the second\nbyte, whose value is F7 16 =-9.",
    "This is in fact the distance in bytes of the instruction following\nthe jg instruction (in this case incl ) to the instruction with label .lb2 .",
    "This negative\nvalue indicates that the destination is above in the memory (i.e., an address with a smaller\nnumeric value).",
    "[HEADER] 4.2.7 Procedures.",
    "A procedure (also called subprogram, function, method, subroutine, handler) is a funda-\nmental concept in software and programming.",
    "It constitutes an important mechanism to\nencapsulate code that implements some functionality with a well-defined set of arguments\nand a return value.",
    "Procedures can be invoked from different points in a program, thus be-\ning a good mechanism to reuse code.",
    "They allow the implementation of some function to\nbe hidden, while providing a clear interface of what arguments are used and what results\nare generated.",
    "To support the discussion in this subsection, assume that procedure procA (the calling or\ncaller procedure) calls procedure procB (the called or callee procedure), which is executed\nand returns back to procA. This simple idea implies the following steps:\n1.",
    "Control :",
    "The instruction pointer must be set to the starting address of the code for procB\nupon entry; when procB ends, the instruction pointer must be set to the instruction in\nprocA that follows the call to procB.\n2.",
    "Arguments and return value : procA must be able to provide the arguments to procB, and\nprocB must be able to return a value back to procA.\n3.",
    "Local memory : procB may need to allocate space for local variables when it starts exe-\ncuting and then free it before returning back to procA.\nThe IA32 support of procedures entails a combination of specific instructions and a set\nof conventions on how to use the machine resources, such as the registers and the program\nmemory.",
    "While procB is executing, procA and its predecessors in the sequence of calls are\ntemporarily in standby.",
    "While procB is running, it is able to allocate new memory space for\nits local variables or to call another procedure (or even itself).",
    "When procB finishes (i.e.,\nreturns the control to procA), the storage allocated must be freed.",
    "This dynamic nature\nof the temporary data within procedures is naturally supported by a stack.",
    "The stack and\nsome registers save the information needed to pass control, the arguments and the return\nCHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE\n64\nvalue, and to allocate memory for local variables.",
    "As procA calls procB, control and data\ninformation is pushed to the stack.",
    "This information is popped when procB returns the\ncontrol to procA.\nThe structure that is created in the stack to support the execution of each procedure call\nis called stack frame (or activation record).",
    "It includes space for the arguments, the return\ninformation, the registers, and the local variables, as shown in Fig. 4.8 .",
    "The stack frames\nfor most procedures are of fixed size, allocated at the beginning of the procedure.",
    "In this\nbook, variable-sized frames are not considered.",
    "Some parts may be omitted if not needed,\nto optimise the program for size or time.",
    "So, in many cases, procedures allocate only the\nparts of stack frames that are strictly needed.",
    "For example, when a given procedure has six\nor fewer arguments, all can be passed in registers.\n...\nlocal variables\nregisters\nreturn address\narguments\n...\nincreasing\n[HEADER] addresses.",
    "Fig. 4.8",
    "The general structure of a stack frame.",
    "Before procedure procA calls procedure procB, it needs to put the arguments into the\nstack frame.",
    "Generically, this can be accomplished by pushing the values of the arguments\ninto the stack with PUSH instructions.",
    "In some cases, arguments are passed in registers,\na faster and more convenient way to do it, but this approach is only possible when the\nnumber of arguments is low (and the chain of calls is relatively short).",
    "When all arguments\nare in the stack, procedure procA can pass the control to procedure procB, simply by setting\nthe instruction pointer (IP) to the starting address of the code for procB (i.e., to its first\ninstruction).",
    "This is similar to a jump instruction, with the difference that the processor\nmust record the code location where it should resume the execution of procA, when procB\nreturns.",
    "This information is recorded by invoking procedure procB with the instruction call\nprocB .",
    "This instruction pushes an address onto the stack, called the return address , and\nsets the IP to the beginning of procB .",
    "The return address is computed as the address of\nthe instruction immediately following the call instruction.",
    "This mechanism is necessary\nsince a procedure can be called from many different parts of the program, and it must be\nable to get back to wherever it was called from.",
    "The formats of the call instructions are listed in Table 4.10 .",
    "Like jumps, call instruc-\ntions can be either direct or indirect.",
    "The target of a direct call is given as a label, whereas\nthe target of an indirect call is given by ‘*’ followed by an operand (a register or a memory\nlocation).",
    "The procB procedure is then responsible for allocating the space required for saving the\nvalues of registers and the local variables.",
    "Registers, whose values need to be preserved, are\n65\n[HEADER] ESSENTIALS OF COMPUTING SYSTEMS.",
    "instruction effect",
    "[HEADER] description.",
    "call l\npushl eip ; eip ← l\nProcedure call\ncall *o\npushl eip ; eip ←∗ o\nProcedure call\nleave\nesp ← ebp ; popl ebp Procedure exit\nret\npopl eip",
    "[HEADER] Return from call.",
    "Table 4.10 Instructions that specifically support procedures in IA32.\n\njust pushed onto the stack.",
    "In fact, not all registers need to be saved, as there is a convention\nthat all programmers and compilers are expected to follow.",
    "A register is classified according\nto two types:\n•",
    "A callee-saved register is a register whose value must be preserved by the callee proce-\ndure;\n•",
    "A caller-saved register is a register whose value must be preserved by the caller proce-\ndure.",
    "Registers ebx, esi, edi, and ebp are classified as callee-saved registers.",
    "When procA calls\nprocB, the latter must preserve the values of these registers, ensuring that they have the\nsame values when procB returns to procA as they had when procB was called.",
    "Procedure\nprocB can preserve a register value by two ways: (1) not changing its value, or (2) pushing the\noriginal value on the stack, using it, and then popping the old value from the stack before\nthe control is passed to procA. Register ebp is used as a reference pointer for accessing all\nthe elements in the stack frame.",
    "Since ebp is a callee-saved register, all called procedures\nmust always save this register.",
    "Registers eax, ecx, and edx are caller-saved registers, which\nmeans that they can be freely modified by a calling procedure.",
    "Thus, it is the responsibility\nof the caller procedure to push these registers onto the stack or copy them somewhere\nelse, before a call is made, whenever one wants to make sure that they are not affected by\na calling procedure.",
    "Space for local data with no specified initial value can be allocated on the stack by just\ndecrementing the stack pointer by an appropriate amount.",
    "The size of the space for local\nvariables must be at least equal to the sum of the sizes of each local variable.",
    "Otherwise, the\ninitial values of the local variables can be directly pushed to the stack.",
    "Each variable must\nbe associated with a specific part of that space.",
    "As happens for arguments, in some cases,\nlocal variables are assigned to registers, but again this approach is only possible when the\nnumber of local variables is low.",
    "When these two allocations (local data and registers) are\nfinished, procedure procB can start its execution.",
    "When procB is finished, the control must be passed to procA. To this end, procB passes\nthe return value, if present, through register eax (recall that this is a caller-saved register).",
    "It\nalso needs to “clean” its stack frame, because it is no longer needed.",
    "So, the parts in the stack\nframe are subsequently freed.",
    "The space for local variables can be deallocated simply by\nincrementing the stack pointer.",
    "The next elements to be freed are the registers.",
    "This implies\npopping their values from the stack.",
    "In this way, the values they had just before procedure\nprocA called procB are recovered.",
    "The last register to be popped is the instruction pointer\n(eip in IA32).",
    "This occurs when the instruction ret (see Table 4.10 ) is executed, which pops\nthe return address from the stack and copies it to the eip.",
    "CHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE\n66\nTo better explain how a stack frame is built in a concrete context, let us assume the\nfollowing procedure sum .",
    "int sum (int n, int v) {\nint i, val=0;\nfor (i=1; i<n; i++)\nval = val + v + i;\nreturn (val);\n}\nIt has two arguments ( n and v ) and two local variables ( i and val ), and returns a value.",
    "All these elements are integers (type int ), which occupy four bytes.",
    "Assume also that in the\nbody of the procedure, registers eax and ebx are modified.",
    "Before procedure sum is called,\nthe state of the registers and the memory is as shown in Fig. 4.9 (a).",
    "The stack pointer points\nto cell 211C 16 .",
    "...\n...",
    "ebp\nesp\n...\n...",
    "ebp\nesp\n...\n...",
    "ebp\nesp\n...\n...",
    "ebp\nesp\n...\n...",
    "ebp\nesp\n...\n...",
    "ebp\nesp\n2100\n2104\n2108\n210C\n2110\n2114\n2118\n211C\n2100\n2104\n2108\n210C\n2110\n2114\n2118\n211C\n2100\n2104\n2108\n210C\n2110\n2114\n2118\n211C\n2100\n2104\n2108\n210C\n2110\n2114\n2118\n211C\n2100\n2104\n2108\n210C\n2110\n2114\n2118\n211C\n2134\n211C\n2134\n2114\nv\nn\n2134\n2110\nv\nn\nret.",
    "address\n210C\n210C\nv\nn\nret. address\nebp\n21OC\n2108\nv\nn\nret. address\nebp\nebx\n210C\n2100\nv\nn\nret.",
    "address\nebp\nebx\ni\nval\n(a)\n(b)\n(c)\n(d)\n(e)\n(f)\nFig. 4.9",
    "The stepwise construction of the stack frame for procedure sum .",
    "The values in the registers and to\nindicate memory addresses are represented in hexadecimal.",
    "The arguments n are v are the first elements to be pushed to the stack.",
    "The responsibility\nof this operation belongs to the calling procedure.",
    "In C programs, the convention is to push\narguments from right to left.",
    "So, the value of v is the first to be pushed to the stack (in\nposition 2118 16 ), followed by the value of n (in position 2114 16 ) as illustrated in Fig. 4.9 (b).",
    "The next step is to call procedure sum , which is obviously executed by the calling pro-\ncedure.",
    "The effect of the call is to write in the top of the stack (position 2110 16 )",
    "the return\naddress and to pass the control to procedure sum , as Fig. 4.9 (c) depicts.",
    "The first instructions of the procedure sum (actually of all procedures) are:\npushl %ebp\nmovl %esp, %ebp\nThe effect of these two instructions is to save register ebp into the stack and to attribute it\na new value, as Fig. 4.9 (d) shows.",
    "This caller-save register is used within the procedure sum\nas the base pointer to access all the elements in the stack frame, by adding or subtracting\n67\nESSENTIALS OF COMPUTING SYSTEMS\nappropriate offsets.",
    "Its value is fixed in this step, which in this case is 210C 16 .",
    "To access, for\nexample, argument n , an offset of +8 needs to be added to ebp.",
    "Argument v requires an\noffset of +12.",
    "Register ebx is also pushed into the stack frame, since its value is changed\nduring the execution of the procedure.",
    "The state of the memory and the registers after this\npush is represented in Fig. 4.9 (e).",
    "The final step is to allocate space for the two local variables (of type int ) and to initialise\nthe value of val with 0.",
    "An alternative to allocate this space is to use the following two\ninstructions:\nsubl %esp, 8\nmovl $0, -12(%ebp)",
    "The subl instruction moves the stack pointer eight positions above, reserving thus this\nnumber of bytes for variables val",
    "and i .",
    "The order of the variables is totally arbitrary, as\nlong as they do not overlap.",
    "The movl instruction initialises the value of val with 0.",
    "Note\nthat this variable is 12 positions ( 2100 16 − 210 C 16 = − C 16 = − 12 ) above in the memory with\nrespect to the position pointed by ebp.",
    "A second alternative to perform this allocation is the following:\nsubl %esp, 4\npushl $0",
    "At this point, the stack frame is complete and the procedure can start its execution.",
    "When\nthe procedure sum is ready to pass the control to its calling procedure, the various steps in\nFig. 4.9 are executed in the reverse order.",
    "The first operation is to pass the return value, which in IA32 follows the convention of\nsimply using register eax for that purpose.",
    "The next step is to deallocate the space occupied\nby the local variables.",
    "This is accomplished by adding +8 to the esp register.",
    "The effect is\nshown in Fig. 4.9 (e).",
    "Next, register ebx is popped from the stack (Fig. 4.9 (d)).",
    "Then, the\nvalue of ebp is also popped from the stack, restoring the stack frame of the caller.",
    "The new\nvalue for ebp is in fact the base pointer for the stack frame of the calling procedure.",
    "This\noperation can be achieved with the instruction leave .",
    "The situation is now represented in\nFig. 4.9 (c).",
    "The next step is jump to the return address with the ret instruction.",
    "This passes\nthe control to the calling procedure and leaves the registers/memory in the state shown in\nFig. 4.9 (b).",
    "Finally, the calling procedure deallocates the space that was used to pass the\narguments.",
    "In this case, this can be made with the instruction add %esp, 8 .",
    "The stack\nreturns to the initial state (Fig. 4.9 (a)).",
    "The conventions for using the registers and the stack permit a procedure to call itself\nrecursively.",
    "In fact, the process followed when a procedure calls itself is roughly the same\nas when it calls a different procedure.",
    "Each procedure call uses its private space on the\nstack, and so the local variables of a specific call do not interfere with those of a different\ncall.",
    "The conventions on using the stack constitute a proper mechanism for allocating local\nstorage whenever a procedure is called and deallocating it whenever returning.",
    "CHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE",
    "[HEADER] 68.",
    "[HEADER] 4.2.8 Data structures.",
    "A scalar variable contains only a value of a primitive datatype, like a character, an integer, or\na floating-point number.",
    "Since a given scalar variable occupies a reduced number of bytes\n(1, 2 or 4, depending on its datatype), it can be saved in the memory or in a given register.",
    "In general, global variables are allocated in memory.",
    "The address of each memory ad-\ndress is determined by the linker, when all modules are merged into a single executable\nprogram.",
    "In assembly, the global variables are referred by their symbolic name (i.e., by the\nrespective label).",
    "Global variables can also be stored in registers, but this is not an approach\nthat can be generalised, as the number of registers is very reduced.",
    "A structured variable is composed of a set of scalar variables and other structured vari-\nables.",
    "Examples of variables in this category are a record in Pascal, a struct and a\nunion in C, and an array , which is a construct available in all high-level languages.",
    "The\nsize of these variables does not permit their allocation to registers.",
    "They should be stored\nin the memory.",
    "C uses a simple implementation of arrays, so the translation into machine code is\nstraightforward.",
    "In C, one can use pointers to access the elements of the arrays and perform\narithmetic with the pointers.",
    "Compilers are good at simplifying the address computations\nused by array indexing.",
    "However, these simplifications make less evident the mapping be-\ntween the C code and its translation into machine code.",
    "Assume the following generic declaration in C, where N is an integer:\ndatatype arr[N];\nThis declaration allocates a contiguous region of N × S bytes in memory, where S is the\nsize in bytes of the datatype.",
    "It also introduces an identifier arr that can be used as a\npointer to the beginning of the array.",
    "The value of this pointer is denoted as b arr .",
    "The array\nelements are accessed using an index that ranges from 0 to N -1.",
    "Array element i is stored\nat address b arr",
    "+ i × S .",
    "To exemplify these concepts, consider the following declarations in C:\nchar e[12];\nint f[5];\nchar *g[4];\nshort int h[5];\nArray e consists of 12 single-byte elements.",
    "Array f consists of five integers, each requir-\ning four bytes.",
    "So, in total, 20 bytes are allocated to this array.",
    "Array g contains pointers,\nand hence the array elements are four bytes each.",
    "In total, it needs 16 bytes.",
    "Elements of\nthe array h have the type short int , each occupying two bytes.",
    "So, this 5-element array\noccupies 10 bytes.",
    "Fig.",
    "4.10 shows for these four arrays the space allocated in the memory\nand the addresses for their elements.",
    "The addressing modes of IA32 ease the access to arrays.",
    "If registers ebx and esi store\nrespectively the base address of array e and the index i that is needed, the following in-\nstruction initialises e[i] with constant value 0.\nmovb $0, (%ebx, %esi, 1)\n69\nESSENTIALS OF COMPUTING SYSTEMS\nb e\nb e +1\nb e +2\nb e +3\nb e +4\nb e +5\nb e +6\nb e",
    "+7\nb e +8\nb e +9\nb e +10\nb e +11\ne[10]\ne[11]\ne[0]\ne[1]\ne[2]\ne[3]\ne[4]\ne[5]\ne[6]\ne[7]\ne[8]\ne[9]\nb f\nb f +4\nb f +8\nb f +12\nb f +16\nf[0]\nf[1]\nf[2]\nf[3]\nf[4]\nb g\nb g +4\nb g +8\nb g +12\ng[0]\ng[1]\ng[2]\ng[3]\nb h\nb h +2\nb h +4\nb h +6\nb h +8\nh[0]\nh[1]\nh[2]\nh[3]",
    "[HEADER] h[4].",
    "Fig. 4.10",
    "The space reserved in the main memory for different arrays.",
    "If esi is equal to 2, the memory address that is affected is given by b e + 2 × 1 , that is two\npositions below the base address which is the location for e[2] .",
    "Similarly, for array f , the following instruction initialises f[i] with constant value 10,\nif registers ebx and esi store the base address of the array f and the index",
    "i that is needed,\nrespectively.\nmovl $10, (%ebx, %esi, 4)",
    "If esi is equal to 4, the memory address that is written is b f + 4 × 4 , that is 16 positions\nabove the base address, which is the location for f[4] .",
    "The general mechanism used for unidimensional arrays also applies when one handles\nmultidimensional arrays.",
    "Consider a two-dimensional array of integers, with two rows and\ntwo columns:\nint i[2][2];\nThis array has four integers, so it occupies 16 bytes.",
    "The array elements are stored in\nthe memory in row-major order, meaning that all the elements of row 0 go first, which are\nfollowed by all elements of row 1.",
    "Fig. 4.11 (a) shows the space allocated in the memory\nand the relative addresses for the elements of array i .",
    "With respect to a struct declaration, its implementation is similar to that of arrays in\nthe sense that all its components are stored in a contiguous area of the memory and the base\npointer to that structure is the address of its first byte.",
    "The compiler uses information about\neach structure type to store the byte offsets of all fields, which are used as displacements\nwith respect to the base address.",
    "As an example, consider the following structure declaration:\nCHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE\n70\nb i\nb i +4\nb i +8\nb i +12\ni[0][0]\ni[0][1]\ni[1][0]\ni[1][1]\n(a)\nb st +8\nb st +4\nb st\nx\ny\nf[0]\nf[1]\nf[2]\nf[3]\nf[4]\nf[5]\nf[6]\nf[7]\n(b)\nFig.",
    "4.11",
    "The space reserved in the main memory for (a) two-dimensional array i and (b) variable st of\ntype struct rec .",
    "struct rec {\nint x;\nint y;\nchar f[8];\n}\nThis structure contains three fields: two 4-byte values of type int , an eight-element\narray of type char , giving a total of 16 bytes.",
    "A possible placement of this structure in\nmemory is illustrated in Fig. 4.11 (b).",
    "This placement is arbitrary in the sense that any ar-\nrangement where the fields are contiguously located is valid.",
    "Notice that the f array is part\nof the structure.",
    "The addressing modes of IA32 are also very convenient to access structures.",
    "Suppose\nthat variable st is of type struct rec .",
    "If register ebx contains the base address of st ,\nthen the following instructions access st.x , st.y and st.f[5] .",
    "To calculate the offset\nfor st.f[5] , one needs to add the offset for the f array field (+8) with the offset of the\narray element with index 5 with respect to the base of that array (+5).",
    "So, the total offset\nis 13.",
    "Note also that the offset of field x is zero, as it is the first field of the structure in the\nmemory.",
    "movl $10, (%ebx)\n/* st.x",
    "= 10 */\nmovl $15, 4(%ebx)\n/* st.y",
    "= 15 */\nmovl $75, 13(%ebx)\n/* st.field[5] = ‘K’ */\n71\n[HEADER] ESSENTIALS OF COMPUTING SYSTEMS.",
    "[HEADER] Exercises.",
    "Exerc. 4.1 : After the execution of instruction movl %ebx, $721 , what are the decimal\nvalues for the contents of registers ebh and ebl?\nExerc. 4.2 : Consider that the following values are stored at the indicated memory addresses\nand registers.",
    "All values are represented in hexadecimal.\naddress value address value register value\n110\nFF\n118\n13\neax\n110\n111\n0\n119\n0\nebx\nA\n112\n0\n11A\n0\necx\n1\n113\n0\n11B\n0\nedx\n3\n114\nAB\n11C\n55\n115\n0\n11D\n0\n116\n0\n11E\n0\n117\n0\n11F\n0\n(a) Calculate the values for the indicated operands: i)",
    "%eax , ii) 0x114 , iii) $0x118 ,\niv) (%eax) , v) 4(%eax) , vi) 9(%eax,%edx) , vii) 280(%ecx,%edx) , viii) 0xFC(,%edx,8) ,\nix) 2(%eax,%ebx) .",
    "(b) For each instruction, indicate the result and where it is stored:\naddl %eax, %ebx\naddl (%eax), %ecx\nsubl 4(%eax), %edx\nandl $43, (%eax,%edx,4)\ndecl %edx\nincl 8(%eax)\nimull %eax,",
    "%ebx\n[HEADER] sall 2, %ebx.",
    "Exerc. 4.3 : Complete the targets of the instructions.\n\n40F780: 75 03\njne XX ...",
    "XX",
    "[HEADER] 8318A1: 0F 85 F1 FE FF FFjne XX ... XX.\n\nExerc. 4.4 : Indicate the addresses of the instructions.",
    "XX ...",
    "XX : 77 20\njne 300834\nXX ...",
    "XX : EB E8\n[HEADER] jmp 854FA2.",
    "Exerc. 4.5 : Consider the following C program, named sc1.c :\n\n<#include<stdio.h>\nint a, b, c;\nint main () {\nscanf(\"%d\", &a);\nb = a*2;\nc = b-a;\nprintf(\"%d %d\\n\", b, c);\n}\nCHAPTER 4.",
    "IA32 INSTRUCTION-SET ARCHITECTURE\n72\nGenerate the assembly code for this program, with the following command line:\ngcc -m32 -O0 -S -o sc1-0.s sc1.c\n(a) Identify how each C instruction/constructor was translated into assembly code\n(b) Repeat the previous question, but first replace the scanf instruction with:\na=10;\n\nExerc. 4.6 : Consider the following C program, named sc2.c :\n\n<#include<stdio.h>\nint i=10, j, k, l;\nint main () {\nscanf(\"%d\", &j);\nif (i<j)\nk = i+j;\nelse\nk",
    "= i-j;\nl=3*k;\n}\nGenerate the assembly code for this program, with the following command lines:",
    "gcc -m32 -O0 -S -o sc2-0.s sc2.c\n(a) Identify how each C instruction/constructor was translated into assembly code.",
    "(b) Identify which modifications occur if the constant 3 in the instruction “l=3*k” is replaced\nby 4, 7, 9, 24, and 39.",
    "Exerc. 4.7 : Consider the following program written in C and analyse the assembly code\ngenerated by the gcc compiler with -O0 option.\n<#include<stdio.h>\nint array[100], sum=0;\nint main () {\nint i;\nfor (i=0; i<100; i++)\nscanf(\"%d\", &array[i]);\nfor (i=0; i<100 && array[i]>0; i++)\nsum += array[i];\n}\nExerc. 4.8 : Consider the following C program and compile it into IA-32 assembly code with\nthe gcc compiler.",
    "1\n#include <stdio.h>\n10\nint badDec2bin (int n) {\n2\nint main() {\n11\nint c;\n4\nint n;\n12\nfor (c=16; c>=0; c-) {\n4\nscanf(\"%d\", &n);\n13\nif (n»c & 16)\n5\nif (n%2!=1)\n14\nprintf(\"1\");\n6\nbadDec2bin(16);\n15\nelse\n7\nelse\n16\nprintf(\"0\");\n8\nbadDec2bin(44);",
    "17\n}\n9\n}\n18\n}\n73\nESSENTIALS OF COMPUTING SYSTEMS\n(a) Build with the maximum detail the stack frame for function badDec2bin , indicating\nthe size and the position of each element.",
    "(b) Identify how the C instructions in lines 5, 8, 12, and 13 have been translated into as-\nsembly code by the gcc compiler with -O0 option.",
    "Exerc. 4.9 : Complete the C program based on the respective assembly code.",
    "int cmpXY (int x, int y) {\ncmpXY: ...\nint val =\nX ... X ;\nmovl 12(%ebp), %eax\nif ( X ... X ) {\nmovl 8(%ebp), %ecx\nif ( X ... X )\nmovl $0, -4(%ebp)\nval =\nX ... X ;\nmovl 8(%ebp), %edx\nelse\ncmpl 12(%ebp), %edx\nval =\nX ... X ;\nje LBB5\n}\njle LBB3\nelse\nmovl $1, -4(%ebp)\nif ( x ... X )\njmp LBB4\nval =\nX ... X ;\nLBB3:\nmovl $2, -4(%ebp)",
    "return val;\nLBB4:\njmp LBB8\n}\nLBB5:\ncmpl $10, 8(%ebp)",
    "jle LBB8\nmovl $3, -4(%ebp)\nLBB8:\nmovl -4(%ebp), %eax\n...",
    "[HEADER] Further reading.",
    "Tanenbaum and Austin ( 2013 , Chapter 1) and Null and Lobur ( 2003 , Chapter 6) present\nthroughout discussions of the different levels one can see a digital computer.",
    "A good complementary source is the book by Bryant and O’Hallaron ( 2011 )",
    "(2nd edition),\nbecause they use Y86, a simpler version of IA32.",
    "The 3rd version of their book ( Bryant and\nO’Hallaron , 2016 ) was upgraded to a 64-bit processor and is obviously also a recommended\nreference.",
    "Not all aspects related to the IA32 assembly language, namely its instruction set is cov-\nered in this chapter.",
    "The interested reader is pointed to the official instruction set docu-\nments provided by Intel in its website.",
    "Blum ( 2005 , Chapter 3) presents in great detail the set of tools that is need for creating\nassembly code programs, with a special focus ion the programming development tools\nprovided by the GNU project.",
    "Other computer architectures are addressed in different books: ARM (and also x86)\n( Stallings , 2019 ), MIPS ( Patterson and Hennessy , 2014 ), MARIE Null and Lobur ( 2003 ), and\nRISC-V ( Hennessy and Patterson , 2017 ).",
    "Chapter 5\n[HEADER] Cache memory.",
    "Abstract A CPU cache is a hardware memory used by the CPU of a computer to reduce the\naverage cost (time or energy) to access data or instructions from the main memory.",
    "A cache\nis a smaller, faster memory, located closer to a processor core, which stores copies of the\ndata and instructions from frequently used main memory locations.",
    "This chapter discusses\nthe main principles of caches, namely the different mapping functions and replacement\nalgorithms.",
    "The concepts and principles discussed here are important, because they can\nbe generalised to other computational contexts.",
    "For instance, mobile applications also use\ncached data, which are files, scripts, images, and other multimedia stored on the mobile\ndevice, after opening the application for the first time.",
    "This data in the cache is then used\nto quickly load information about the application every time it is reopen.",
    "[HEADER] 5.1 Main principles.",
    "CPUs have always been faster than memories.",
    "As semiconductor technology progresses, this\nprocessor-memory gap continues to increase.",
    "It is easier and cheaper to make processors\nrun faster than it is to make main memory operate faster.",
    "So, whenever the CPU needs to\naccess the main memory, it must wait for many CPU cycles.",
    "The slower the memory, the more\ncycles the CPU must wait.",
    "This undoubtedly degrades the performance of the computer.",
    "A typical solution to the processor-memory gap is to design a computer to have cache\nmemory .",
    "Caches are designed to combine the access time of expensive and fast memory\nwith the large size of cheap but slow memory.",
    "The purpose of a cache is to speed up memory\naccesses by storing recently used data closer to the CPU, instead of storing it in the memory.",
    "Although the cache is not as large as the main memory, it is significantly faster.",
    "The basic idea for using a cache is simple: the most frequently requested memory words\nare stored in the cache.",
    "Whenever the CPU needs a given word, it first looks in the cache.",
    "It is expected that most of the times, the needed word is stored in the cache.",
    "If this is not\nthe case, then the CPU must access the main memory to get it.",
    "If a substantial percentage\nof the words are in the cache, the average access time is greatly reduced.",
    "75\nCHAPTER 5.",
    "CACHE MEMORY\n76\ncache\nCPU\nmain\nmemory\n[HEADER] bus.\n\nFig.",
    "5.1",
    "The cache is logically between the CPU and main memory.",
    "The success of the cache in reducing the accesses to the memory greatly depends on\nwhat fraction of the words are in the cache.",
    "The fact that programs do not access the mem-\nory completely in an arbitrary way favours the success of caches.",
    "The use of the memory\nhas some degree of predictability.",
    "In fact, an important observation related to the execution\nof programs is the principle of locality .",
    "Programs tend to reuse data and instructions that\nwere recently used.",
    "A well-known rule of thumb is that many programs spend 90% of their\nexecution times in 10% of the code.",
    "Thus, one can predict which instructions and pieces of\ndata are to be used in the near future based on the most recent accesses.",
    "This principle has\ntwo different types:\n• temporal locality implies that recently accessed data or instructions are likely to be\nneeded in the near future;\n• spatial locality states that items whose memory addresses are close to each other tend\nto be referenced close together in time.",
    "These two types of locality are observed, for example, during the execution of a loop\nthat accesses all the elements of an array or matrix, which are contiguously stored in the\nmemory.",
    "This principles also applies to code, as instructions, by default, are fetched and\nexecuted by the processor from consecutive positions in the memory, except for jumps and\nprocedure calls.",
    "Furthermore, most program execution time is spent in loops, in which a\nreduced number of instructions are repeatedly executed.",
    "Whenever the processor tries to obtain a given word from the cache but fails because the\ndata is not stored there, i.e., whenever there is a cache miss , the word must be read from\nmemory.",
    "To take into account the two types of locality, instead of just getting that specific\nword, its neighbours are also brought from the main memory into the cache, because it is\nvery likely that many of them will be needed shortly.",
    "This approach is more efficient than\nfetching individual words, since it is faster to fetch n words all at once than one word n\ntimes.",
    "A cache hit occurs when the requested data is located in the cache.",
    "With the number\nof hits and misses, it is possible to calculate the hit rate and the miss rate , which are the\npercentages of memory accesses found and not found, respectively, in the cache, during\nthe execution of a program or of a part of it.",
    "The time required to fetch the requested data\nin the cache is designated as hit time .",
    "The miss penalty is the time required to process a\nmiss, which includes substituting a block in the cache and the additional time to deliver the\nrequested data to the processor.",
    "Typically, the time to process a hit is significantly smaller\nthan the time to process a miss.",
    "77\nESSENTIALS OF COMPUTING SYSTEMS\nTo explain how caches operate, consider Fig.",
    "5.2 , which depicts the elements of a\ncache/main-memory system.",
    "A cache block is the minimum unit of transfer between the\ncache and the main memory.",
    "This term also refers to the physical location in the main\nmemory and in the cache.",
    "A cache line is the portion of the cache memory that can store\none block.",
    "A line includes control information, namely a tag , which is a group of bits that\npermits identifying the memory address of the block stored in that cache line.",
    "Each cache\nline also includes a valid bit that indicates whether the data in the line is valid or not.",
    "When\nthe system is booted, all cache lines are obviously marked as not valid.",
    "CACHE\n#line\nvalid bit\nr-bit\ntag\nblock\n0\n1\n2\nm -1\nblock length",
    "[HEADER] K words.\n\n...",
    "MEMORY\nn-bit\naddress\n0\n1\n2\n3\n[HEADER] 2 n -1.",
    "...\n\nblock 0\n( K words)",
    "block M -1\n( K words)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[HEADER] .\n\nFig.",
    "5.2",
    "A memory-cache system.",
    "The main memory is composed of 2 n addressable words, with each one having a unique\nn -bit address.",
    "This memory is viewed, for the purpose of transferring data from or to the\ncache, as consisting of a number of fixed-length blocks of K words each.",
    "So, M blocks exist\nin the main memory ( M = 2 n\nK ).",
    "The cache consists of m lines.",
    "Each line contains a block ( K\nwords), plus a tag.",
    "Each line also includes control bits (not shown), such as a bit to indicate\nwhether the line has been modified since it was loaded into the cache.",
    "The line size is the\nlength of a line, not including tag and control bits, i.e., it refers to the number of data bytes\ncontained in a line.",
    "The number of lines is much smaller than the number of the main memory blocks ( m ≪\nM ).",
    "In each moment, the cache contains a subset of the blocks of memory.",
    "If a word is read\nfrom memory , the respective block is transferred to one of the lines of the cache.",
    "Because\nthere are more blocks than lines, an individual line cannot be uniquely and permanently\ndedicated to a particular block.",
    "Thus, each line includes a tag that identifies which particular\nblock is currently being stored.",
    "The tag is usually the initial part of the address of the main\nmemory.",
    "CHAPTER 5.",
    "CACHE MEMORY\n78",
    "Whenever reading a word from the memory, the processor requests that word from the\ncache.",
    "If there is a hit, it is delivered to the processor.",
    "When a cache miss occurs, the block\ncontaining the word must be loaded into the cache, not just the word needed, and the\nrequested word must be delivered to the processor.",
    "For example, with a 64-byte line size,\na reference to memory address 772 ( 001100 000100 2 ) brings the line consisting of bytes\n768 ( 001100 000000 2 ) to 831 ( 001100 111111 2 ) into one cache line.",
    "If a word is read or written w times in a very short interval, the computer needs one\nreference to the main memory and w − 1 references to the cache.",
    "The larger w is, the better\nthe overall performance.",
    "To formalise this calculation, the following values are needed:\nthe cache access time t c , the main memory access time t m (which is the same as the miss\npenalty), and the hit ratio r h .",
    "In the previous example, r h = w − 1\nw .",
    "The miss ratio is given by\nr m = 1 − r h .",
    "The mean access time is calculated by t ma = t c + r m × t m .",
    "If r h → 1 ( r m → 0 ), all\nreferences can be obtained from the cache, and the access time approaches t c .",
    "Contrarily, if\nr h → 0 ( r m → 1 ), a memory reference is needed every time, so the access time approaches t c +\nt m , first a time t c to unsuccessfully check the cache, and then a time t m to access the memory.",
    "Some systems initiate the memory reference simultaneously with the cache search, so that\nif a cache miss occurs, the memory cycle is already under way.",
    "This strategy is however\nharder to implement.",
    "[HEADER] 5.2 Mapping function.",
    "Contrarily to what happens with the main memory, caches are not accessed by address,\nbut instead by content.",
    "For this reason, cache is often called content-addressable memory\n(CAM) .",
    "In the cache, both (part of) the address and the content are stored side by side.",
    "When\na given memory address is being requested, all cache entries must be searched to check\nif it is stored there.",
    "When the address matches, the corresponding content is fetched from\nthe cache memory.",
    "This need results from the fact that the number of cache lines is smaller than the number\nof memory blocks.",
    "Therefore, an algorithm for mapping memory blocks into cache lines is\nneeded.",
    "Additionally, one needs a mechanism for determining which specific main memory\nblock currently occupies a cache line.",
    "The selection of the mapping function determines\nhow the cache is logically organised.",
    "Three techniques are usually adopted: direct, associa-\ntive, and set-associative.",
    "To explain the concepts associated with caches, assume the memory-cache system illus-\ntrated in Fig.",
    "5.3 .",
    "This system has a cache with four lines ( m = 4 ), each one storing two words\n( K = 2 ).",
    "The memory has 16 positions, which implies 4-bit addresses ( n = 4 ).",
    "In this exam-\nple, the address is at the byte level, which is aligned with most contemporary machines.",
    "In\ntotal, there are eight different blocks in the memory ( M = 8 ).",
    "The simplest approach is direct mapping , which maps each block of main memory into\nonly one possible cache line.",
    "This mapping follows a modular approach.",
    "The number of\nthe cache line i is given by formula i = j mod m , where j is the memory block number.",
    "The memory block number is given by the memory address but ignoring the log 2 K LSBs.",
    "So, for the example, the mapping is expressed as i = j mod 4 .",
    "Therefore, blocks 0 and 4\n79\nESSENTIALS OF COMPUTING SYSTEMS\nCACHE\n#line\n1-bit\ntag\nblocks\n�\n��\n�\n0 00\n1 01\n2 10\n3 11\nblock length\n( 2 words)\nMEMORY\n4-bit\naddress\n0 0000\n1 0001\n2 0010\n3 0011\n4 0100\n5 0101\n6 0110\n7 0111\n8 1000\n9 1001\n10 1010\n11 1011\n12 1100\n13 1101\n14 1110\n15 1111\n�\n�\n�\n�\n�\n�\n�\n�\nblock 0 000\nblock 1 001\nblock 2 010\nblock 3 011\nblock 4 100\nblock 5 101\nblock 6 110\nblock 7 111\nFig.",
    "5.3",
    "A small memory-cache system with direct mapping.",
    "All numbers are indicated in decimal and\nbinary.",
    "( j ∈{ 0 , 4 } ) are mapped to line 0",
    "( i = 0 ), blocks 1 and 5 to line 1, and so on (the colours in\nFig. 5.3 show which blocks map into which cache lines).",
    "So, the two last bits of the block\nnumber (i.e., the two central bits of the memory addresses) indicate the respective cache\nline.",
    "The MSB of the block number is stored in the tag of the cache line, to identify which\nblock is stored there.",
    "If a ‘0’ is stored in the tag of cache line ‘10’, the block that is stored\nthere is 010 (block 2); if instead the tag stores a ‘1’, the block is 110 (block 6).",
    "In general,\nwith this technique, blocks 0 , m , 2 m , ... all map to cache line number 0.",
    "Similarly, blocks 1 ,\nm + 1 , 2 m + 1 , ... all map to cache line number 1, and so on.",
    "The direct mapping function can be implemented using the main memory address.",
    "For\nthe purpose of cache access, each main memory address can be viewed as consisting of\nthree fields: the o LSBs identify a unique word or byte within a memory block ( o = log 2 K ).",
    "The next b bits specify part of the block number ( b = log 2 m ).",
    "The remaining t bits are saved\nin the tag ( t = n − b − o ).",
    "Again, for the example, o = log 2 2 = 1 , b = log 2 4 = 2 , and t =\n4 − 2 − 1 = 1 , as Fig. 5.4 shows.\n1 bit\n2 bits\n1 bit\n4 bits\nt\nb\no\n1\n1\n0\n0\nFig.",
    "5.4 The three fields of the memory addresses for a direct mapped cache.",
    "Example with address 1100 2 ,\nwhich is mapped to cache line 10 2 and whose tag is 1.\nCHAPTER 5.",
    "CACHE MEMORY\n80\nThe direct mapping technique is inexpensive to implement.",
    "Its major drawback is that\neach memory block has a unique cache location.",
    "If a program refers words repeatedly from\ntwo different blocks that map into the same line, then the blocks need to be repeatedly\nswapped in the cache.",
    "The hit ratio becomes very low and the cache is not able to improve\nthe performance of the program.",
    "The disadvantage of the direct mapping can be overcome by the fully associative map-\nping , which allows each memory block to be loaded into any cache line.",
    "Thus, all the words\nof the block, as usual, and also the block number (i.e., the bit pattern that encodes the block\nnumber) must be stored in the cache line.",
    "Fig.",
    "5.5 shows a fully associative mapped cache similar to the one in Fig. 5.3 .",
    "The major\ndifferences are the possibility to map each memory block to any cache line and the bigger\nsize of the tag.",
    "In this case, the tag has 3-bits, since the cache line where a block is stored\ngives no clue about the block number.",
    "CACHE\n#line\n3-bit\ntag\nblocks\n�\n��\n�\n0 00\n1 01\n2 10\n3 11\nblock length\n( 2 words)\nMEMORY\n4-bit\naddress\n0 0000\n1 0001\n2 0010\n3 0011\n4 0100\n5 0101\n6 0110\n7 0111\n8 1000\n9 1001\n10 1010\n11 1011\n12 1100\n13 1101\n14 1110\n15 1111\n�\n�\n�\n�\n�\n�\n�\n�\nblock 0 000\nblock 1 001\nblock 2 010\nblock 3 011\nblock 4 100\nblock 5 101\nblock 6 110\nblock 7 111\nFig.",
    "5.5",
    "A small memory-cache system with fully associative mapping.",
    "All numbers are indicated in decimal\nand binary.",
    "For the purpose of cache access, each main memory address can be viewed as consisting\nof two fields: the o LSBs identify a unique word or byte within a memory block ( o = log 2 K ).",
    "The remaining t bits are saved in the tag ( t = n − o ).",
    "Again, for the example, o = log 2 2 = 1\nand t = 4 − 1 = 3 , as Fig. 5.6 shows.",
    "There is a third mapping scheme designated as set associative mapping , which is a com-\nbination of the direct and the fully associative mappings.",
    "It is similar to direct mapping,\nsince the address is used to map the memory block to a certain cache location.",
    "The major\ndifference here is that instead of mapping to a single cache block, an address maps to a set\nof cache blocks.",
    "The sets have all the same size.",
    "For example, in a 2-way set associative\ncache ( N = 2 ), there are two cache blocks per set, as Fig. 5.7 depicts.",
    "In this case, there are\n81\nESSENTIALS OF COMPUTING SYSTEMS\n3 bits\n1 bit\n4 bits\nt\no\n1\n1\n0\n0\nFig.",
    "5.6",
    "The two fields of the memory addresses for a fully associative mapped cache.",
    "Example with address\n1100 2 , which can be mapped to any cache line and whose tag is 110 2 .\nonly two cache sets ( m = 2 ), so the cache is able to store four 2-word memory blocks.",
    "Direct\nmapped cache can be seen as a special case of N-way set associative cache mapping where\nthe set size is one.",
    "CACHE\n#line\n2-bit\ntag\n2-bit\ntag\nblocks\n�\n��\n�\nblocks\n�\n��\n�\n0\n1\nblock length\n( 2 words)\nMEMORY\n4-bit\naddress\n0 0000\n1 0001\n2 0010\n3 0011\n4 0100\n5 0101\n6 0110\n7 0111\n8 1000\n9 1001\n10 1010\n11 1011\n12 1100\n13 1101\n14 1110\n15 1111\n�\n�\n�\n�\n�\n�\n�\n�\nblock 0 000\nblock 1 001\nblock 2 010\nblock 3 011\nblock 4 100\nblock 5 101\nblock 6 110\nblock 7 111\nFig.",
    "5.7",
    "A small memory-cache system with 2-way set associative mapping.",
    "All numbers are indicated in\ndecimal and binary.",
    "The 2-way set associative mapping function can be implemented using the main memory\naddress.",
    "For the purpose of cache access, each main memory address can be viewed as\nconsisting of three fields: the o LSBs identify a unique word or byte within a memory block\n( o = log 2 K ).",
    "The next s bits specify the set number ( s = log 2 m ).",
    "The remaining t bits are\nsaved in the tag ( t = n − s − o ).",
    "Again, for the example, o = log 2 2 = 1 , b = log 2 2 = 1 , and\nt = 4 − 1 − 1 = 2 , as shown in Fig. 5.8 .\nCHAPTER 5.",
    "CACHE MEMORY\n82\n2 bits\n1 bit 1 bit\n4 bits\nt\ns\no\n1\n1\n0\n0\nFig.",
    "5.8",
    "The three fields of the memory addresses for a 2-way set associative mapped cache.",
    "Example with\naddress 1100 2 , which is mapped to cache line 0 and whose tag is 11 2 .",
    "[HEADER] 5.3 Replacement algorithm.",
    "In a direct-mapped cache, if there is contention for a cache block, there is only one possible\naction: the existing block is removed from the cache to make room for the new block.",
    "This\nprocess is called replacement.",
    "With direct mapping, there is no need for a sophisticated\nreplacement algorithm, since the location for each new block is fixed.",
    "Anyhow, with direct\nmapping, if a block already occupies the cache location where a new block is about to be\nplaced, the block currently in the cache should be updated in the main memory if it has\nbeen modified after being loaded into the cache.",
    "For associative mappings, whenever the cache is full and a new block needs be stored,\na replacement algorithm is needed.",
    "It decides in which cache line to store the new block.",
    "Many alternatives exist for this algorithm.",
    "If temporal locality is considered, it is likely that any value that has not been used re-\ncently will not be needed again soon.",
    "If the last time each cache line was accessed is reg-\nistered, it is possible to select for replacement the line that has been used least recently.",
    "This is the least recently used (LRU) algorithm, which requires the system to keep a history\nof accesses for every cache line.",
    "Another possible approach is the first in first out (FIFO)\nstrategy.",
    "The block that has been in cache the longest is selected as the one to be replaced\nby the new block.",
    "Another alternative is to randomly select the cache line to be replaced.",
    "Other possibilities are the not most-recently used (NMRU) that randomly choose among\nall blocks but the one most recently referenced, and the least frequently used (LFU) that\nreplaces the block that has been referenced the fewest number of times.",
    "The algorithm\nselected by the computer architects often depends on how the system is to be used.",
    "This\nselection is not trivial as no single algorithm is the best for all contexts.",
    "[HEADER] Exercises.",
    "Note: In all exercises in this chapter, assume that a word is four bytes and that the memory\nis addressed at the byte level.",
    "Exerc. 5.1 : Consider four computers with different caches:\n\n• C1 : direct mapping, 2 20 words of main memory, cache with 32 blocks, cache block with\n16 words.",
    "•",
    "C2 : direct mapping, 2 32 bytes of main memory, cache with 1024 blocks, cache block with\n32 words.",
    "83\nESSENTIALS OF COMPUTING SYSTEMS\n• C3 : fully associative mapping, 2 16 words of main memory, cache with 64 blocks, cache\nblock with 32 words.",
    "• C4 : fully associative mapping, 2 24 words of main memory, cache with 128 blocks, cache\nblock with 64 words.",
    "(a) Calculate the number of blocks that exist in the main memory.",
    "(b) Draw the format of a memory address as seen by each cache, indicating the sizes of the\ntag, block (when applicable), and offset fields?",
    "(c) Indicate the cache block to where is mapped the memory reference 3DB63 16 in C1 and\n13463FA 16 in C2.",
    "Specify in each case the tag value.",
    "(d) Calculate the size in bytes of each cache.\nExerc. 5.2 : Consider a computer with a memory with 128Mi words.",
    "Blocks are 64 words in\nlength and the cache consists of 32Ki blocks.",
    "For a 2-way set associative cache mapping\nscheme, illustrate the format for a main memory address, including the fields and their\nsizes.",
    "Exerc. 5.3 : A 2-way set associative cache consists of four sets.",
    "The main memory contains\n2Ki 8-word blocks.",
    "(a) Show the main memory address format (including the fields and their sizes) that allows\nmapping the addresses from main memory to the cache.\n(b) Compute the hit ratio for a program that loops three times from locations 8 to 55 in\nmain memory.",
    "Assume that all instructions occupy four bytes.",
    "Exerc.",
    "5.4 : A computer, using a set associative cache, has 2 16 words of main memory and a\ncache of 32 blocks, and each cache block contains eight words.",
    "(a) What is the format of a memory address as seen by a 2-way set associative cache, i.e.,\nwhat are the sizes of the tag, set, and word fields?",
    "(b) Repeat the previous question if the cache is 4-way set associative.",
    "Exerc. 5.5 :",
    "A computer uses a memory address word size of 8 bits.",
    "This computer has a\n16-byte direct-mapped cache with 4 bytes per block.",
    "The format of a memory address as\nseen by the cache is the following:\n4 bits\n2 bits\n2 bits\n8 bits\nt\nb\no\nWhile running a program, the computer accesses several memory locations, according to\nthe following sequence: 6D, B9, E3, 16, E3, 4E, 4F, 14, 91, A4, A5, A7, A9, 98, and 99 (in\nhexadecimal).",
    "The memory addresses of the first four accesses have been loaded into the\ncache blocks as shown below.",
    "The contents of the tag are shown in binary and the cache\ncontents are simply the hexadecimal addresses whose contents are stored at each cache\nlocation.",
    "block\n0\n1\n2\n3\ntag\n1110\n0001\n1011\n0110\n(E0)\n(E1)\n(E2)\n(E3)\n(14)\n(15)\n(16)\n(17)\n(B8)\n(B9)\n(BA)\n(BB)\n(6C)\n(6D)\n(6E)\n(6F)\nCHAPTER 5.",
    "CACHE MEMORY\n84\n(a)",
    "What is the hit ratio for the memory reference sequence given above?\n(b) What memory blocks are in the cache after the last address has been accessed?\nExerc. 5.6 : Consider a byte-addressable computer with 24-bit addresses, a cache capable of\nstoring a total of 64KiB of data, and blocks of 32 bytes.",
    "Show the format of a 24-bit memory\naddress for the following mapping functions: (a) direct, (b) fully associative, and (c) 16-way\nset associative.",
    "[HEADER] Further reading.",
    "Caches constitute a topic that is addressed by all books on computer architecture, namely by\nthose written by Tanenbaum and Austin ( 2013 , Chapter 2), Patterson and Hennessy ( 2014 ,\nChapter 5), Bryant and O’Hallaron ( 2016 , Chapter 6), and Stallings ( 2019 , Chapter 5).",
    "An-\nother interesting material about caches is provided by Null and Lobur ( 2003 , Chapter 6).",
    "In\nparticular, they present non-computer examples of caching, which are quite enlightening to\nunderstand its major principles.",
    "A very complete and detail survey about caches authored\nby Smith ( 1982 ) is also worth reading.",
    "Chapter 6\n[HEADER] Code optimisations.",
    "Abstract The primary objective in writing a computer program is to make it work correctly.",
    "But programs should also address quality attributes (also designated non-functional re-\nquirements), namely performance, size and maintainability.",
    "There are situations where, for\nexample, it is relevant to reduce the time a program takes to execute.",
    "This chapter explores\nhow to make programs execute faster through several different types of program optimisa-\ntion.",
    "[HEADER] 6.1 Main principles.",
    "Writing an efficient program in a given high-level programming language requires several\ntypes of skills.",
    "First, one must select the adequate algorithms and data structures.",
    "Second,\nsource code must be in such a condition that the compiler can effectively produce code that\nruns as fast as possible or that occupies the minimum space.",
    "Speed and size are the tradi-\ntional criteria of optimisation addressed by compilers, but energy consumption is gaining\nimportance due to environmental reasons and the popularisation of mobile devices that are\nnot always connected to the electric grid.",
    "It is relevant to comprehend the capabilities and\nlimitations of the compilers, when they try to apply some type of code optimisation to the\nprograms.",
    "The term “optimisation” is somehow abusive as there is no guarantee that the\nresult is the best possible (i.e., the optimum).",
    "Often, minor changes in the source program\ncan have a profound impact in the quality of the machine code generated by the compiler.",
    "It is important that programmers know these differences, since this knowledge may allow\nprograms to be written in ways that make them more amenable for compilers to generate\n(more) efficient code.",
    "In approaching program development and optimisation, some aspects must be taken into\naccount, like the way the code is expected to be used and the critical factors affecting it.",
    "In\ngeneral, programmers must establish a trade-off between several criteria, like performance,\nsize, portability, and readability.",
    "These criteria are non-functional requirements and each\none cannot be achieved in an isolated way.",
    "This means that one cannot maximise a given\nnon-functional requirement without sacrificing some other non-functional requirements.\n85\nCHAPTER 6.",
    "CODE OPTIMISATIONS\n86\nThe selected level for the satisfaction of a given non-functional requirement affects, either\npositively or negatively, the satisfaction of other non-functional requirements.",
    "For example,\na program optimised for performance can see a reduction in its characteristics associated\nwith maintainability.",
    "In a simple way, one can say that the fastest program is probably\nwritten in a very cryptic way and is difficult to change (and to maintain).",
    "Traditionally, C\ncompilers, namely gcc , only handle size and speed.",
    "A new criterion, energy consumption,\ngained importance in the last decades.",
    "At the algorithmic level, there are differences between a normal algorithm and a more\nefficient one.",
    "Usually, the former can be programmed in a matter of minutes, while the\nlatter requires more effort to implement and refine.",
    "At the coding level, many low-level\noptimisations tend to reduce the readability and the modularity of the program, making\nharder its modification.",
    "For code that is expected to execute repeatedly and whose performance is relevant,\napplying optimisations is worthwhile.",
    "However, it is important to maintain some level of\nreadability in the code.",
    "A compiler is able to take a valid program written in the source\nlanguage code and generate a behaviourally-equivalent machine-level program.",
    "Compilers\nmake use of sophisticated mechanisms to generate code that can be optimised according\nto different metrics.",
    "[HEADER] 6.2 Limitations of the compilers.",
    "Most compilers employ advanced techniques to determine what values are computed in a\nprogram and how they are used.",
    "The compilers can exploit opportunities to simplify expres-\nsions, to use a single computation in several different places, and to reduce the number of\ntimes a given computation must be performed.",
    "Most compilers allow programmers to con-\ntrol the level of optimisations.",
    "For example, gcc can be used with the option -O to specify\nwhich type of optimisations to apply.",
    "Compilers must be careful to apply only safe optimisations to a program, which means\nthat the resulting program must have the same external behaviour as an unoptimised ver-\nsion for all possible paths the program may take.",
    "A compiler is expected to be conservative\nin applying optimisations in the sense that, whenever in doubt, it does not go ahead with\nthem.",
    "The compiler operates in a constrained context.",
    "Firstly, it must not modify the be-\nhaviour of the program under any possible condition.",
    "Often, this restriction prevents the\ncompiler from applying optimisations that would only affect behaviour under illogical, but\npossible, conditions.",
    "Secondly, the compiler has a limited and localised view of the program,\nso broader optimisations are not applied.",
    "Thirdly, the compilation process itself must be fast\nenough, so (marginal) gains are not appreciated if the compiler needs a large amount of\ntime to achieve them.",
    "Compilers usually have problems in dealing with any optimisation blocker , which is an\naspect of computer programs that can greatly limit the opportunities for a compiler to\ngenerate optimised code.",
    "Often, the optimisation blockers are dependent on the execu-\ntion environment.",
    "An example of an optimisation blocker is present in the following two\nimplementations of the same procedure:\n87\nESSENTIALS OF COMPUTING SYSTEMS\nint pr1(int *x, int *y) {\nint pr2(int *x, int *y) {\n* x += * y;\n* x +=\n2* *y ;\n* x += * y;\n}\n}",
    "It seems safe to transform the first version of the procedure into the second one, as both\napparently have identical behaviour.",
    "They both add twice the value stored at the location\ndesignated by pointer y to that designated by pointer x .",
    "Procedure pr2 is more efficient,\nsince it requires only three memory references (read *x , read *y , write *x ), while pr1 re-\nquires six (read twice *x , read twice *y , and write twice *x ).",
    "So, it seems that a compiler\nwhen handling procedure pr1 could generate more efficient code based on the computa-\ntions performed by the equivalent pr2 .",
    "This approach cannot however be applied when x\nand y are equal.",
    "Then procedure pr1 performs the following computations:\n* x += * x;\n/* double value at x */\n* x += * x;\n/* double value at x */\nThe value at x is thus increased by a factor of four.",
    "However, procedure pr2 executes\nthe following computation:\n* x += 2 * * x;\n/* triple value at x */",
    "The result is that the value at x is increased by a factor of three.",
    "The compiler cannot\nassume that arguments x and y are not equal.",
    "Therefore, the compiler cannot generate\ncode in the style of pr2 as an optimised version of pr1 .",
    "The situation where two pointers\nmay designate the same memory location is called as memory aliasing .",
    "Compilers tend to\nassume that different pointers may be aliased.",
    "Another optimisation blocker may occur when a function has side effects.",
    "A function\n(or expression) has a side effect , if it alters the values of some variables outside its local\ncontext.",
    "So, the function has an observable effect besides returning a value to the calling\nprocedure.",
    "Consider the two following versions of a function, which appear to have the\nsame behaviour:\nint func1(int x) {\nint func2(int x) {\nreturn (f(x)+f(x));\nreturn ( 2*f(x) );\n}\n}",
    "However, if the function f has the following implementation and counter is a global\ninteger variable, then the two versions of the function are not equivalent.",
    "int f(int p) {\nreturn (p+counter++);\n}",
    "Note, that the expression p+counter++ , calculates the value p+counter and af-\nterwards increments the value of counter by one.",
    "If counter is equal to 0, calling\nfunc1(5) returns 11 ( 5 + 6 ), while calling func2(5) returns 10 ( 2 × 5 ).",
    "The value of\ncounter is also different in both cases: 2 after calling func1 and 1 after func2 .",
    "Another example is the following procedure lower2upper that converts the lowercase\nletters of a string into uppercase ones.",
    "It seems that the expression strlen(s) can be\nCHAPTER 6.",
    "CODE OPTIMISATIONS\n88\nsafely calculated outside the loop just once, avoiding thus several calls to the strlen\nfunction.",
    "void lower2upper(char *s) {\nvoid lower2upper(char *s) {\nint i;\nint i, length=strlen(s);\nfor (i=0; i<strlen(s); i++)\nfor (i=0; i< length ; i++)\nif (s[i]>=‘a’ && s[i]<=‘z’)",
    "if (s[i]>=‘a’ && s[i]<=‘z’)\ns[i] -= (‘a’ - ‘A’);\ns[i] -= (‘a’ - ‘A’);\n}\n}\nCompilers tend to keep the call to strlen inside the loop, because it can have side ef-\nfects.",
    "Additionally, the loop body may change the string and its size.",
    "Compilers usually treat\nprocedures as black boxes that cannot be analysed.",
    "Following a conservative approach,\ncompilers assume the worst case and the function call remains intact.",
    "In this case, the\ncompiler may actually apply the optimisation, as long as strlen is recognised as a built-\nin function.",
    "These examples, which just cover some dimensions of the issues associated with code\noptimisation, show that it is often important that programmers know how to write code\nthat can be easily optimised by a compiler.",
    "The optimisations can be divided into two major\ngroups:\n1. machine-independent optimisations;",
    "2. machine-dependent optimisations;\nIn the two next sections, some of the approaches and techniques applied in each of these\ntwo groups are presented and discussed.",
    "The discussion presents fragments of assembly\ncode, which in some cases were generated by the gcc compiler.",
    "The examples serve to\nshow how to examine assembly code and relate it to the high-level program languages.",
    "The reader may also try to obtain fragments of assembly code with a C compiler, but most\nlikely they will be different from the ones presented here.",
    "Anyhow, they are behaviourally\nequivalent.",
    "The analysis made here may require some adaptation for the examples obtained\nby the reader.",
    "[HEADER] 6.3 Machine-independent optimisations.",
    "Machine-independent optimisations improve the target code without taking into account\nany properties at the machine level.",
    "They include, for example, choosing the best (i.e., the\nfastest) algorithm for the problem at hand.",
    "This issue is not addressed in this book, as it is\noutside its scope.",
    "Other optimisations that fit in this group are:\n1. code motion;",
    "2. elimination of unnecessary accesses to memory;\n3. loop unrolling;\n4. reduction of the number of procedure calls.",
    "The next subsections explain these four optimisations based on illustrative examples.",
    "89\n[HEADER] ESSENTIALS OF COMPUTING SYSTEMS.",
    "[HEADER] 6.3.1 Code motion.",
    "Loops are good candidates for improvements, as they have an iterative nature.",
    "The most\ntypical cases of code motion consists of statements in a loop or some of their parts (like,\nexpressions) that can be moved outside its body, without affecting its semantics.",
    "The idea\nhere is that moving statements from the inside to the outside of the loop obviously reduces\nthe execution time of the program.",
    "In the piece of C code on the left, two optimisations are\npossible, which results in the code on the right:",
    "do {\nx=y+z;\nx=y+z;\nint const j=x*x;\na[i]=i+x*x;\ndo {\ni++;\na[i]=i+ j ;\n} while (i<n);\ni++;\n} while (i<n);",
    "First, the statement that calculates the values of x does not depend on variables that are\nmodified inside the DO-WHILE loop body, so it can be moved to the outside.",
    "Additionally,\nthe value of x*x just needs to be calculated once (outside the loop) and can be reused in\neach iteration of the loop.",
    "The use of the const qualifier indicates that j is read-only.",
    "Similar transformations can be applied to WHILE-DO loops, but in some cases the result\nis more complex.",
    "A WHILE-DO loop starts by testing the condition, while a DO-WHILE loop\ninitiates by executing the loop body.",
    "The former executes the loop body zero or more times,\nwhile the latter executes the loop body at least once.",
    "In the piece of C code in the right\nside, the need of an IF-THEN statement prevents the loop to execute if the loop condition\nfails in the very first iteration.",
    "In that case, the loop body is not executed.",
    "while (i<n) {\nif (i < n)\n{\nx=y+z;\nx=y+z;\na[i]=i+x*x;\nint const j=x*x;\ni++;\ndo {\n}\na[i]=i+ j ;\ni++;\n} while (i<n);\n}\nThese two examples justify why compilers try to transform WHILE-DO (and FOR ) loops in\nequivalent DO-WHILE loops, to avoid the IF-THEN statement.",
    "For example, the following\ntwo blocks have equivalent behaviour, since it is guaranteed",
    "that the FOR loop executes\nat least once (in this case, i equals 0 in the beginning and the loop executes while it is\nsmaller than 100):\nfor (i=0; i<100; i++) {\ni=0;\n...",
    "do {\n}\n...\ni++;\n} while (i<100);\nCHAPTER 6.",
    "CODE OPTIMISATIONS\n90",
    "The assembly code for DO-WHILE loops, in general, can be made much simpler (i.e.,\nfaster) than the equivalent versions using WHILE-DO and FOR loops, as already discussed\nin Subsection 4.2.6 .",
    "[HEADER] 6.3.2",
    "Elimination of unnecessary accesses to memory.",
    "Accesses to main memory, which are significantly slower than those to registers, are also\nobvious candidates to optimise the performance of a program.",
    "Consider the following pro-\ncedure:\nint addAll (int *a, int *value) {\nint i;\n* value=0;\nfor (i=0; i<100; i++)\n* value += a[i];\n}\nThe addition inside the for loop accesses the argument value , which was passed as a\npointer.",
    "So, in general, this argument is in the memory as occurs in the following piece of\nassembly code:\naddAll:\n...",
    "movl 12(%ebp), %edx\nmovl 8(%ebp), %esi\nmovl $0, (%edx)\nxorl %ecx, %ecx\nLBB0:\nmovl (%esi,%ecx,4), %eax",
    "addl %eax, (%edx)\nincl %ecx\ncmpl $100, %ecx\njne LBB0\n...",
    "There is here an opportunity for improvement, since there are two accesses to the mem-\nory for each loop iteration: one to read the value of the respective array element ( movl\n(%esi,%ecx,4), %eax ) and another one to accumulate it into the value argument\n( addl %eax, (%edx) ).",
    "It is possible to just write this value to memory at the end of the\nloop.",
    "As the next C program shows, the optimisation is based on accumulating the sum of\nall elements of the array arr into a local variable and on assigning it to a register.",
    "int addAll (int *arr, int *value) {\nint i;\nint acc=0;\nfor (i=0; i<100; i++)\nacc\n+= arr[i];\n* value=acc;\n}\n91\nESSENTIALS OF COMPUTING SYSTEMS\nThe assembly code for this new version of the procedure shows that there is only one access\nto the memory in each loop iteration ( addl (%esi,%ecx,4), %eax ).",
    "This is a relevant\nimprovement as memory accesses are much slower than accesses to registers.\naddAll:\n...",
    "movl 12(%ebp), %edx\nmovl 8(%ebp), %esi\nmovl $0, %eax\nxorl %ecx, %ecx\nLBB0:\naddl (%esi,%ecx,4), %eax\nincl %ecx\ncmpl $100, %ecx\njne LBB0\nmovl %eax, (%edx)\n...",
    "[HEADER] 6.3.3 Loop unrolling.",
    "A well-known code optimisation technique is loop unrolling , which aims reducing the num-\nber of iterations for a loop, by increasing the number of elements computed on each iter-\nation.",
    "The rationale behind this technique is the fact that each loop iteration incurs in\nsome non-effective computations, related to the control of the loop (incrementing the loop\nvariable, comparing it and jumping to the beginning of the loop).",
    "Thus, by decreasing the\nnumber of the operations that do not contribute directly to the program result, the loop is\nmade faster.",
    "It is straightforward to apply loop unrolling to array processing loops, whenever the\nnumber of iterations is known at compile time.",
    "The next code fragments show three similar\nloops that iterate through a 120-element array, with different levels of unrolling.",
    "1\ni=0;\n2\ni=0;\n3\narr[0]=0;\ndo {\ndo {\narr[1]=0;\narr[i]=0;\narr[i]=0;\narr[2]=0;\ni++;\narr[i+1]=0;\n...\n} while (i<120);\narr[i+2]=0;\narr[119]=0;\narr[i+3]=0;\ni+=4;\n} while (i<120);",
    "In fragment 1, all iterations include an increment and a comparison/jump.",
    "Fragment 2\nuses loop unrolling to improve performance, by handling a block of four elements in each\niteration.",
    "The new loop has to make only 30 iterations, instead of 120.",
    "Consequently, only\n25% of the jumps and conditional branches need to be taken, which represents a significant\ndecrease in the loop administration overhead.",
    "However, the new loop occupies more space,\nas it includes more C statements (an also more machine instructions).",
    "Fragment 3 is the\nfastest solution, but also the one with the highest number of C instructions (120).",
    "In this\nCHAPTER 6. CODE OPTIMISATIONS\n92\ncase, there is no loop overhead, as there is literally no loop.",
    "As these examples illustrate,\nloop unrolling constitutes a space–time tradeoff, since it attempts to optimise the execution\nspeed of a given program at the expense of its binary size.",
    "The following assembly code blocks are the possible translations of the first two C code\nfragments presented above.",
    "1\nmovl $0, %eax\n2\nmovl $0, %eax\n.lbl:\n.lbl:\nmovl $0, arr(,%eax,4)\nmovl $0, arr(,%eax,4)\nincl %eax\nmovl $0, arr+4(,%eax,4)\ncmpl $120, %eax\nmovl $0, arr+8(,%eax,4)",
    "jle .lbl\nmovl $0, arr+12(,%eax,4)\naddl $4, %eax\ncmpl $120, %",
    "eax\njle",
    ".lbl",
    "It is simple to calculate the number of machine instructions that is executed in both ver-\nsions of the code (for 120 array positions).",
    "In fragments 1 and 2, the number of executed\ninstructions is 481 ( 1 + 120 × 4 ) and 211 ( 1 + 30 × 7 ), respectively.",
    "If one assumes, for sim-\nplification purposes, that all instructions take the same time to execute (which is not the\ncase), the reduction in time is around 56%.",
    "Generalising, if the array has n positions and a block of k ≤ n / 2 positions are manipulated\nin each iteration, the total number of instructions that are executed within the loop is given\nby 1 +( 3 + k ) ×⌊ n / k ⌋",
    "+( n mod k ) .",
    "Note that if n is not a multiple of k , additional instructions\nneed to be put at the beginning or the end of the loop.",
    "For instance, if n = 21 and k = 4 ,\nthere are five iterations with blocks of four elements, plus one instruction outside the loop\nto handle the remaining element.",
    "Note also that it does not make sense to have k > n / 2 ,\nbecause in those situations the loop is useless, as it is just executed once.",
    "Fig.",
    "6.1 shows\nthe number of instructions that need to be executed considering different values for the\nnumber of elements of the 120-element array that are handled in each loop iteration.",
    "The\nperformance improves whenever the block has more elements, but the code also includes\na higher number of machine instructions (it occupies more space in memory).",
    "10\n20\n30\n40\n50\n60\n100\n200\n300\n400\n500\n•\n•\n•\n•\n• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • •\nFig.",
    "6.1 Loop unrolling metrics for a loop that initialises the 120 elements of an array.",
    "The XX axis repre-\nsents the number of elements handled in each loop iteration, while the YY axis represents the total number\nof instructions needed to run the loop.",
    "93\n[HEADER] ESSENTIALS OF COMPUTING SYSTEMS.",
    "[HEADER] 6.3.4 Reduction of the number of procedure calls.",
    "Procedure calls imply a great overhead (pushing arguments, saving return address, jumping\nto procedure, managing stack frame, passing result) and also tend to block many possible\nprogram optimisations.",
    "The idea of replacing a procedure call by the body of the called\nprocedure is called inline expansion (or inlining).",
    "This optimisation reduces time, at the cost\nof increasing the space usage.",
    "The code expansion due to the replication of the procedure\nbody dominates, except for simple cases.",
    "An inlined procedure run faster than the normal procedure, as the calling overheads\nare avoided.",
    "However, there is a memory penalty, i.e., code gets larger.",
    "If a procedure is\ninlined n times, n copies of the function body are inserted into the code.",
    "Maintenance of\nthe procedure gets harder and more error prone, because when the body of the procedure\nneeds to be changed, one must update it in n places.",
    "Thus, inlining is adequate for small\nfunctions.",
    "Consider the following C function that returns 1 if the argument num is even, and 0\notherwise (if it is odd):\nint isEven (int num) {\nreturn !(num & 1);\n}\nAssume that this function is invoked in some part of a program:\nif (isEven (number))",
    "A possible optimisation of this code is to replace the call to function isEven with the\nrespective body.",
    "[HEADER] if (!(number & 1)).",
    "[HEADER] 6.4 Machine-dependent optimisations.",
    "Machine-dependent optimisations, as the name suggests, depend on the specific processor\nthat is being considered.",
    "Optimisations that work in a given processor are not necessarily\neffective in a different one.",
    "Optimisations that fit in this category are related to the use of instructions that are faster\nor occupy less space in memory.",
    "When a given high-level statement or construct can be sup-\nported by different machine-level alternatives, it is possible to use the best one, according\nto the preferred criterion.",
    "For example, in IA32 to assign the value 0 to a register can be\ndone with any of the two following alternatives:\nmovl $0, %eax\nxorl",
    "%eax, %eax",
    "The movl instruction occupies more space in memory, as it includes a 32-bit immediate\nvalue.",
    "So, compilers usually select the xorl alternative.",
    "CHAPTER 6. CODE OPTIMISATIONS\n94\nAnother typical example occurs with multiplications, which in some processors take\nmuch longer to execute that additions and shifts.",
    "So, whenever compilers encounter a mul-\ntiplication involving a variable and a constant, they transform the multiplication in a series\nof additions and shifts.",
    "The simple situations occur when the constant is a power of two.",
    "Consider the following piece of C code:\ny = 8*a;\nMultiplying by 8 is equivalent to shift the bits 3 positions to the left.",
    "So, this multiplica-\ntion can be optimally supported by using the following instructions, which assume variables\na and y to be saved in registers eax and ebx, respectively:\nmovl %eax, %ebx\nsall 3,",
    "%ebx\nThings are not that simple when the constant is not a power of two.",
    "Consider now the\nfollowing piece of C code:\ny = 37*a;\nA straightforward approach to tackle this C statement is to use the three-operand mul-\ntiplication in IA32:\nimull $37, %eax, %ebx\nIt is also possible to use additions and shifts to calculate this multiplication.",
    "Since 37 =\n32 + 4 + 1 , calculating 37 · a is equivalent to compute 32 · a + 4 · a + a .",
    "So, this multiplication\ncan be optimally supported by the following IA32 instructions:\nmovl %eax, %ecx\n/* ecx = a */\nmovl %ecx, %ebx\n/* ebx = a */\nsall 2, %ecx\n/* eax = 4xa */\naddl %ecx, %ebx\n/* ebx = a + 4xa",
    "= 5xa */\nsall 3, %ecx\n/* eax = 8x4a = 32xa */\naddl %ecx, %ebx\n/* ebx = 5xa + 32xa = 37xa */",
    "The efficient computation of addresses is another machine-dependent optimisation.",
    "Again, assume the C code discussed in Subsection 6.3.3 that initiates the values of a 120-\nelement array and particularly the execution of the following statement\narr[i]=0;\nIf i is saved in register ecx and the initial address of the array arr is in register ebx, then\nthe two following alternatives for the assembly code are possible.",
    "The left-sided solution\nis the preferred one, as it is both faster and shorter.",
    "It benefits from the rich addressing\nmodes available in the IA32 instruction set.",
    "The right-sided solution calculates the address\noutside the movl instruction.",
    "movl $0, (%ebx,%ecx,4)\nmovl %ecx, %edx\nsall 2, %edx\naddl %edx, %ebx\nmovl $0, (%ebx)",
    "95\n[HEADER] ESSENTIALS OF COMPUTING SYSTEMS.",
    "[HEADER] 6.5 Cache-oriented optimisations.",
    "A program that exhibits good locality is very likely to execute faster than one that does\nnot.",
    "Good locality is possible if a program refers data items that are near other recently ref-\nerenced data items or that were recently referenced themselves.",
    "This situation may have\na great impact on the performance of the program, because the hit rate of the cache gets\nhigher.",
    "Therefore, programmers must understand the principle of locality in order to posi-\ntively exploit it.",
    "In fact, this principle is present in all levels of modern computer systems,\nfrom the hardware, to the operating system, to the software application.",
    "For example, web\nbrowsers explore temporal locality by locally caching recently referenced documents.",
    "Consider a slightly different version of the addAll procedure, which accesses and sums\nall the elements of an array.",
    "int addAll (int *arr) {\nint i, acc=0;\nfor (i=0; i<100; i++)\nacc += arr[i];\nreturn (acc);\n}\nThis procedure has a good temporal locality with respect to local variables i and acc ,\nwhich are accessed in every loop iteration.",
    "The elements of array arr are accessed one after\nthe other, in the same order as they are in the memory.",
    "So, the procedure has good spatial\nlocality with respect to array arr .",
    "Overall, the addAll procedure exhibits good locality.",
    "It\nhas a stride-1 reference pattern, as it accesses each element of the array sequentially.",
    "The\nstride of an array is the number of locations in memory between successive array elements,\nmeasured in bytes or in units of the size of the array’s elements.",
    "In general, as the stride\nincreases, the spatial locality decreases, since two element arrays consecutively accessed\nare more distant.",
    "To highlight the importance of writing code that takes into account the existence of\ncache memories, consider the two following pieces of code that add all the elements of a\ntwo-dimensional matrix arr , where all variables are of type int :\n1\nfor (i=0; i<100; i++)\n2\nfor (i=0; i<100; i++)\nfor (j=0; j<100; j++)\nfor (j=0; j<100; j++)",
    "acc += arr[i][j];\nacc += arr [j][i] ;\nFig.",
    "6.2 shows the access order of the array elements for both pieces of code.",
    "It is observ-\nable in Fig.",
    "6.2 (a) that for the first piece of code the elements are accessed sequentially.",
    "For\nthe second one, the access is not sequential.",
    "In fact, the stride is 100 units (or 400 bytes).",
    "With respect to the array, the conclusion is that the first piece of code presents a good\nspatial locality, while the second one does not.",
    "[HEADER] Exercises.",
    "Exerc. 6.1 : Consider again the two C programs in Exercise 4.5 and the one in Exercise 4.6.",
    "Generate new versions of the assembly code for those programs, with the -O1 , -O2",
    "-O3\nCHAPTER 6. CODE OPTIMISATIONS\n96\n...\n...\n...\n1\n2\n3\n99\n100\n101\n102\n200\n201\n10 000\n...\n...\n...\n1\n101\n201\n9801\n9901\n2\n102\n9902\n3\n10 000\n[0][0]",
    "[0][1]",
    "[0][2]",
    "[0][98]",
    "[0][99]\n[1][0]",
    "[1][1]",
    "[1][99]",
    "[2][0]",
    "[99][99]\n(a)",
    "[HEADER] (b).",
    "Fig.",
    "6.2 A 100x100 array in memory and the access order according to different programs.",
    "-Os compilation flags.",
    "For each C program, compare the new versions of the assembly code\nwith the one obtained with the -O0 compilation flag.\nExerc.",
    "6.2 : Consider again the C programs in Exercises 4.7, 4.8, and 4.9 and analyse the\nassembly code generated with different levels of optimisation.",
    "Exerc.",
    "6.3 :",
    "For each block of code, calculate the stride associated with the access to array\nvec .",
    "#define size 500\n1\nfor (i=0; i<size; i++)\ntypedef struct {\nfor (j=0; j<2; j++) {\nint a[2];\nvec[i].a[j]=0;\nint b[2];\nvec[i].b[j]=0;\n} rec;\n}\nrec vec[size];\n2\nfor (i=0; i<size; i++)\n3\nfor (j=0; j<2; j++)\nfor (j=0; j<2; j++)\nfor (i=0; i<size; i++)\nvec[i].a[j]=0;\nvec[i].a[j]=0;\nfor (j=0; j<2; j++)\nfor (i=0; i<size; i++)\nvec[i].b[j]=0;\nvec[i].b[j]=0;\n97\nESSENTIALS OF COMPUTING SYSTEMS\nExerc. 6.4 :",
    "Change the order of the index variables i , j , and k in the if statement, so that\nthe procedure accesses array arr with a stride-1 reference pattern.",
    "int countNulls(int arr[N][N][N]) {\nint i, j, k, count = 1;\nfor (j=N-1; i>=0; i-)\nfor (k=N-1; j>=0; j-)\nfor (i=N-1; k>=0; k-)",
    "if (arr[k][i][j]==0)\ncount++;\nreturn count;",
    "[HEADER] }.",
    "[HEADER] Further reading.",
    "The topic of program optimisation is too large, so in this chapter only a reduced number\nof techniques were touched on.",
    "The interested reader is pointed to the landmark book\non compilers, written by Aho et al. ( 1986 , chapters 9 and 10), to learn more about code\noptimisation.",
    "Bryant and O’Hallaron ( 2016 , Chapter 5) present many relevant aspects related to the\noptimisation of assembly code, obtained by C compilers.",
    "Blum ( 2005 , Chapter 15) discusses\ncommon methods to optimise assembly code, including calculations, variables, loops, and\nconditional branches.",
    "[HEADER] Solutions to exercises.",
    "1.3 : Memory cells 132104 to 132107 are affected.",
    "Values 00010010, 00110100, 01010110,\nand 01111000 are stored in cells 132104, 132105, 132106, and 132107, respectively.",
    "1.4 :\n0000 1111 0000 0000 1111 1111 0001 0010.",
    "1.5 : Generically, this accident is not positive.",
    "The program was modified and no longer will behave exactly as programmed.",
    "Depending\non the location of the modified instruction, the program may terminate abruptly or may\nshow a strange behaviour.",
    "1.6 : (a): 120 000 s; (b) 35 085 s.\n2.1 :",
    "The encoding is valid; DLXII. 2.2 : “U. Minho”.",
    "2.3 : 49 , 152 bytes.",
    "2.4 : 1111 2 and 15 10 .\n2.5 : 62 4 > 1 . 4 · 10 7 . 2.6 : 126 3 > 2 · 10 6 . 2.7 : 6 KB; 5 . 86 KiB. 2.8 : 12 bits. 2.9 : (a) 63 , 151 , 360 B;\n(b) 21 .",
    "982 MiB; (c) 1 . 28",
    "PiB.\n3.1 : minimum 0 . 01",
    "EUR; maximum 99 , 999 , 999 .",
    "99",
    "EUR. 3.2 : (a) 10000011 2 ; (b) 111111111 2 ;\n(c) 1101111000 2 ; (d) 1000000000000 2 . 3.3 : (a) 31; (b) 1023; (c) 262,143; (d) 4,294,967,295.",
    "3.4 : 0 ( 0000 2 ) , 1 ( 0001 2 ) , 2 ( 0010 2 ) , 3 ( 0011 2 ) , 4 ( 0100 2 ) , 5 ( 0101 2 ) , 6 ( 0110 2 ) , 7 ( 0111 2 ) , 8 ( 1000 2 ) ,\n9 ( 1001 2 ) , A ( 1010 2 ) , B ( 1011 2 ) , and C ( 1100 2 ).",
    "3.5 : (a) BED 16 ; (b) 276 16 ; (c) 7 FF 16 ; (d) 51 E 16 . 3.6 :\n(a) 1011111011101111 2 ; (b) 1000000000000 .",
    "11111111 2 ; (c) 101010111100 .",
    "110111101111 2 ;\n(d) 110110101100 .",
    "001101 2 . 3.7 : (a) 302 5 ; (b) 1011 5 ; (c) 4021 5 ; (d) 13 , 000 5 . 3.8 : (a) 60 ; (b) 102 ;\n(c) 259 ; (d) 648 .",
    "3.9 : (a) 1000010 2 , 123 7 , 73 9 ,; (b) 319 .",
    "25 10 , 227 .",
    "3 12 ; (c) 11020 .",
    "( 1 ) 3 , 1302 .",
    "2 4 ,\n222 .",
    "( 3 ) 7 ; (d) 11100110000 2 , 12304 6 , 3460 8 . 3.10 : This value corresponds to 2 30 , which means\nthat this computer has a memory that is addressed with 30 bits.",
    "3.11 : 9 hours, 25 minutes,\nand 46 seconds.",
    "3.12 : 3000000 16 .",
    "3.13 : 16 bits.",
    "3.14 : 17 bits; 16 bits. 3.15 : 950 bits.",
    "3.16 :\n3 · 2 20 > 3 · 10 6 .",
    "3.17 :",
    "A 32-bit signed integer variable was used to represent the number\nof views.",
    "The maximum value in this representation is 2,147,483,647.",
    "If this value is incre-\nmented the result is negative.",
    "The simplest solution is to change the datatype to 32-bit\nunsigned integer.",
    "YouTube engineers decided to change the datatype to 64-bit signed in-\nteger.",
    "3.18 : (a) 9 ; (b) 4 . 3.19 : (a) 1001000 2 ; (b) 1528 12 ; (c) 1641 16 . 3.20 : (a) 8764 ; (b) 9963 ;\n(c) 888 878 .",
    "3.21 : (a) 1100100 2 ; (b) 0011001101 2 ; (c) 11111111 2 ; (d) 00011111111 2 . 3.22 :\n(a) 00010010 2 in all; (b) 1111001 2 in all; (c) 10100001 2 , 11011110 2 , 11011111 2 ; (d) 11100100 2 ,\n10011011 2 , 10011100 2 . 3.23 : (a) − 199 ; (b) − 312 ; (c) − 313 ; (d) 200 . 3.24 : (a) 1011101001 2 ;\n(b) 1100010110 2 ; (c) 1100010111 2 ; (d) 0100010110 2 . 3.25 : (a) 11111 2 ; (b) 10110 2 ; (c) 1010010 2 ;\n(d) 1 . 3.26 : (a) 100100 2 ; (b) 1100100 2 ; (c) 1011010100 2 ; (d) 11000011 2 . 3.27 : (a) overflow;\n99\nSOLUTIONS TO EXERCISES\n100\n(b) overflow; (c) 11001010 ; (d) overflow.",
    "3.28 : (a) ( − 1 ) s × ( 1 + f )",
    "× 2 e − 7 , ( − 1 ) s × ( 1 + f )",
    "×\n2 e − 3 ; (b) i) 0 0000 001 2 =\n1\n512 , 0 000 0001 2 = 1\n64 , ii) 0 0000 111 2 =\n7\n512 , 0 000 1111 2 = 15\n64 ,\niii) 0 0001 000 2 = 1\n64 , 0 001 0000 2 = 1\n4 , iv) 0 0111 000, 0 011 0000, v) 0 1110 111 2 =240,\n0 110 1111 2 = 15\n2 ; (c) i)",
    "− 11\n16 , ii) NaN, iii) − 9\n256 , iv)\n3\n512 , v) − 2 . 25 ; (d) i) 1 1010 101, ii) 0",
    "1110\n000, iii) 0 1101 110, iv) 1 1111 000 ( − ∞ ), v) 0 0000 101; (e) i) 0 010 0110, ii) 1 111 0000,\niii) 0 000 0010, iv) 1 101 1100, v) 1 000 0000.",
    "4.1 : ebh=2 and ebl=209.",
    "4.2 : (a) i. 110 16 , ii.",
    "AB 16 , iii. 118 16 , iv.",
    "FF 16 , v. AB 16 , vi. 55 16 ,\nvii.",
    "55 16 , viii.",
    "AB 16 , ix.",
    "55 16 ; (b) ebx= 11 A 16 , ecx= 100 16 , edx= − 168 , M[ 11 C 16 ]= 1 (4 bytes), edx= 2 ,\nM[ 118 16 ]= 14 16 (4 bytes), ebx=AA 0 16 , edx= 28 16 .",
    "4.3 : 40 F 785 ; 831798 .",
    "4.4 : 300812 ; 854 FB 8 . 4.8 :\nsee below 4.9 : 0 ; x!=y ; x>y or x>=y ; 1; 2; x>10 ; 3.",
    "[HEADER] 4.8 : (a).\n\n...",
    "c\nebp\nret.",
    "address\nn\nbp-8\nbp-4\nbp\nbp+4",
    "Each element occupies four bytes in memory.\n5.1 : (a) C1: 2 16 , C2: 2 25 , C3: 2 11 , C4: 2 18 ; (b) C1: tag 11 bits, block 5 bits, offset 6 bits,\nC2: tag 15 bits, block 10 bits, offset 7 bits, C3: tag 16 bits, offset 2 bits, C4: tag 24 bits,\noffset 2 bits; (c) C1: block 01101 2",
    "=13, tag 00001111011 2 , C2: 00 1100 0111 2 =199, tag\n000000010011010 2 ; (d) C1: 2400 , C2: 146 , 432 , C3: 9216 , C4: 35 , 840 .",
    "5.2 : tag 7 bits, set\n14 bits, offset 8 bits.",
    "5.3 : (a) tag 9 bits, set 2 bits, offset 5 bits; (b) 17\n18 . 5.4 : (a) tag 9 bits,\nset 4 bits, offset 5 bits; (b) tag 10 bits, set 3 bits, offset 5 bits.",
    "5.5 : a) 2\n5 ; (b) see below.",
    "5.6 :\n(a) tag 8 bits, block 11 bits, offset 5 bits; (b) tag 19 bits, offset 5 bits; (c) tag 15 bits, set\n4 bits, offset 5 bits. 5.5 : (b)\n1001\n1010\n1001\n0100\n(90)\n(91)\n(92)\n(93)\n(A4)\n(A5)\n(A6)\n(A7)\n(98)\n(99)\n(9A)\n(9B)\n(4C)\n(4D)\n(4E)",
    "[HEADER] (4F).\n\n6.3 : 2 units (8 bytes); 1 unit (4 bytes); 4 units (16 bytes); 6.4 : arr[j][k][i] .",
    "[HEADER] Glossary.\n\nabsolute jump\nbranch instruction whose possible target is given by a complete memory address; the\nsame as long jump.",
    "62\naddress\nlocation in memory of an operand.",
    "7\narithmetic logic unit (ALU)\ncombinational digital circuit that performs arithmetic and logical operations in a CPU.",
    "6\nASCII\ncharacter encoding standard for electronic communication.",
    "18\nassembler\ncomputer program that translates programs written in assembly language into machine\nlanguage.",
    "3\nassembly phase\nprocess undertaken to convert an assembly language into an object program.",
    "49\nbinary-coded decimal (BCD)\nclass of binary encodings of decimal numbers in which each decimal digit is represented\nby a specific binary pattern with a fixed number of bits.",
    "41\nbias\ninteger value that is subtracted to the natural value of a bit pattern to obtain its corre-\nsponding value in an excess representation; the same as offset.",
    "33\nbig endian\norder of bytes of a word in computer memory, which stores the least-significant byte at\nthe largest address; see also little endian.",
    "8\nbinary point\nsign used to separate the integer part of a binary number from its fractional part.",
    "26\nbit\nbasic unit of information that represents a logical state with one of two possible values;\nthe same as binary digit.",
    "16\n101\nGLOSSARY\n102\nbranch instruction\ninstruction in a program that can cause a computer to begin the execution of a different\ninstruction sequence, thus deviating from its default behaviour of executing instructions\nin sequential order.",
    "12\nbus\ncommunication system that transfers data between components inside a computer or\nbetween computers.",
    "5\nbyte\nunit of digital information that consists of eight bits.",
    "17\ncache block\nminimum unit of transfer between the cache and the main memory.",
    "77\ncache hit\nsuccessful attempt to read or write a piece of data in the cache.",
    "76\ncache line\nportion of the cache memory that can store one block.",
    "77\ncache memory\nhigh-speed memory used to store frequently accessed or recently accessed data and\ninstructions, so that future requests for that data/instructions can be provided faster.",
    "75\ncache miss\nrequest to access data from the cache that is not filled because the data are not present\nin the cache, which implies an access to the main memory.",
    "76\ncallee-saved register\nprocessor register whose value must be preserved by the callee procedure.",
    "65\ncaller-saved register\nprocessor register whose value must be preserved by the caller procedure.",
    "65\ncell\nsmallest addressable unit of the main memory.",
    "7\ncentral processing unit (CPU)\ncomponent of a computer that orchestrate the execution of the instructions that belong\nto a program, by controlling all the other parts; the same as processor.",
    "5\nclock\nsignal that regulates the passage of time within the computer.",
    "6\ncode optimisation\ntransformation technique that tries to improve the code of a program according to a\ngiven criterion, like speed, size, or energy consumption.",
    "85\ncolour depth\nnumber of bits used to indicate the colour (or the colour component) of a single pixel.\n22\ncompilation phase\nprocess undertaken to convert a program written in high-level programming language\ninto an equivalent assembly-language program; process that converts a high-level pro-\ngram into an executable program that the computer can directly execute.",
    "49\ncomputer\nmachine that can be programmed to carry out sequences of operations automatically.",
    "1\n103\nGLOSSARY\ncondition code\nbit that saves a given post-operation condition (e.g., an arithmetic overflow), which can\nbe read to decide subsequent instructions, namely conditional jumps.",
    "59\ncontent-addressable memory (CAM)\ncomputer memory that accesses the stored information based on input data (either com-\npletely or in part), rather than on input address.",
    "78\ncontrol unit\ncomponent of a CPU that directs the operation of the computer.",
    "6\ndata dependency\nsituation in a pipelined CPU in which the result of one instruction, not yet available, is\nalso the operand of a subsequent instruction.",
    "12\ndecimal point\nsign used to separate the integer part of a decimal number from its fractional part in a\npositional numeral system.",
    "26\ndevice driver\nsoftware executed by the CPU when it has to deal with the respective device.",
    "10\ndigit\nsymbol used alone or in combinations to represent numbers in a positional numeral\nsystem.",
    "25\ndigital abstraction\nprocess by which analog (or continuous) behaviour is ignored and is rather seen as dis-\ncrete.",
    "16\ndirect mapping\ncache mapping scheme that maps blocks of memory to blocks in cache using a modular\napproach.",
    "78\ndynamic random access memory (DRAM)\ntype of RAM that stores each bit of data in a memory cell consisting of a tiny capacitor\nand a transistor, both typically based on metal-oxide-semiconductor (MOS) technology.",
    "7\nend carry-around\ntype of carry required when two integers, represented as a radix-minus-one complement\nnumbers, are summed.",
    "32\nexcess-b representation\ndigital integer coding representation, where all-zero corresponds to the minimal value\nand all-one to the maximal value; the same as offset binary and biased representation.",
    "33\nexponent\npart of a number expressed in a scientific notation that indicates the integer value that\nthe base should be raised to, in order to obtain the desired value.",
    "37\nfetch-decode-execute cycle\nset of steps a computer follows to execute an instruction.",
    "6\nfixed-point number\nnumber represented in a numeral system with a radix point in a fixed position.",
    "36\nGLOSSARY\n104\nfloating-point number\nnon-integer fractional number represented as a product of a mantissa with an integer\npower of the base; the same as number in scientific notation.",
    "36\nfully associative mapping\ncache mapping scheme that maps blocks of main memory to any block in the cache. 80\nhexadecimal numeral system\nbase-16 numeral system that uses the digits 0 to F. 27\nhit rate\nfraction of memory references that are found in the cache during the execution of (a part\nof) a program.",
    "76\nhit time\ntime to deliver a word stored in the cache to the CPU.",
    "76\nIEEE 745 floating-point standard\ntechnical standard for floating-point arithmetic originally established by the Institute of\nElectrical and Electronics Engineers (IEEE) in 1985; significantly revised by IEEE 754-\n2008, published in August 2008.",
    "40\nimage resolution\nnumber of pixels per space unit (traditionally an inch) of an image.",
    "22\ninline expansion\ncode optimisation technique that substitutes a procedure call with the body of the called\nprocedure; the same as inlining.",
    "93\ninstruction pointer (IP)\nspecial-purpose register of a processor that indicates where a computer is in its program\nsequence; the same as program counter. 6\ninstruction register (IR)\nspecial-purpose register of a processor that stores the instruction currently being exe-\ncuted or decoded.",
    "6\ninterrupt\nsignal sent by a device to the CPU to request its attention, thus interrupting the normal\nfetch-decode-execute cycle of execution.",
    "10\nI/O device\nhardware system used by humans or systems to communicate with a computer.",
    "9\nlabel\nsequence of characters (string) that identifies a specific location within the source code.",
    "61\nlatency\nnumber of clock cycles needed to complete the execution of an instruction.",
    "11\nleast-significant bit (LSB)\nbit of a binary number located at the far right of the string.",
    "27\nleast-significant digit (LSD)\ndigit of a number located at the far right of the string.",
    "27\n105\nGLOSSARY\nline size\nnumber of data bytes contained in a cache line, excluding the tag and the control bits.",
    "77\nlinking phase\nprocess of collecting and combining various pieces of code and data into a single file\nthat can be loaded into memory and executed.",
    "49\nlittle endian\norder of bytes of a word in computer memory, which stores the least-significant byte at\nthe smallest address; see also big endian.",
    "8\nloader\nprogram that loads other programs and libraries into memory and prepares them for\nexecution.",
    "49\nloop unrolling\ncode optimisation technique that expands a loop so that each new iteration contains sev-\neral of the original iterations, thus performing more effective computations per iteration\nand reducing the control overhead.",
    "91\nmachine language\nprogramming language that provides little or no abstraction from the instruction set\narchitecture of a computer; the same as low-level programming language.",
    "2\nmagnitude\nabsolute value of a number; the same as modulus. 31\nmain memory\nstorage system, typically implemented with RAM memory, used to store data and instruc-\ntions for immediate use in a computer; the same as memory.",
    "7\nmantissa\nfractional part of a number expressed in a scientific notation; the same as significand.",
    "38\nmean access time\nmetric to analyse the performance of a cache-memory system, based on the cache access\ntime, the miss penalty, and the hit ratio.",
    "78\nmemory aliasing\nsituation in which a data location in memory can be accessed through different symbolic\nnames.",
    "87\nmicroprogram\nprogram used to interpret instructions into machine language.",
    "3\nmiss penalty\ntime required to process a cache miss, including the replacement of the block in the\ncache and the delivery of the requested data to the processor.",
    "76\nmiss rate\nfraction of memory references that are not found in the cache during the execution of (a\npart of) a program.",
    "76\nmost-significant bit (MSB)\nbit of a binary number located at the far left of the string.",
    "27\nmost-significant digit (MSD)\ndigit of a number located at the far left of the string.",
    "27\nGLOSSARY\n106\nnatural number\nnumber used for counting and ordering; the same as non-negative integer or counting\nnumber.",
    "26\nnibble\ngroup of four bits; half a byte.",
    "17\nnormal number\nnon-zero number in a floating-point representation which is within the supported bal-\nanced range; the same as normalised number.",
    "37\nnot a number (NaN)\nmember of a numeric data type that can be interpreted as a value that is undefined or\nunrepresentable.",
    "39\nnumeral system\na mathematical notation for representing numbers of a given set, using digits or other\nsymbols; the same as number system or system of numeration.",
    "25\noctal numeral system\nbase-8 numeral system that uses the digits 0 to 7. 27\none’s complement\ncomplement of a n -bit number with respect to 2 n − 1 . 32\none’s complement numeral system\nnumeral system in which a negative number is represented by the inverse of the binary\nrepresentation of its corresponding positive number.",
    "31\noperating system\nsystem software that manages computer hardware, software resources, and provides\ncommon services for computer programs.",
    "3\noptimisation blocker\naspect of a computer program that can limit the opportunities for a compiler to generate\noptimised machine-level code.",
    "86\noverflow\nsituation that occurs when the value of an integer number is outside the range that can\nbe represented with a given fixed-sized numeral system (either higher than the maximum\nor lower than the minimum representable values).",
    "33\npipelining\ntechnique for implementing instruction-level parallelism within a single processor, by\ndividing instructions into a series of sequential steps performed by different processor\nunits in parallel.",
    "10\npixel\nthe smallest addressable element in a raster image.",
    "21\npolling\nthe process of synchronously checking the status of an external device by a program.",
    "10\npositional numeral system\nsystem for representing numbers by an ordered set of digits, in which the value of each\ndigit depends on its position.",
    "25\n107\nGLOSSARY\npreprocessing phase\npre-compilation step in which the text of a high-level program is substituted according\nto the indicated directives.",
    "48\nprinciple of locality\ntendency of a processor to access the same set of memory locations repetitively over a\nshort period of time, when executing a program.",
    "76\nprocedure\nsequence of program instructions that performs a specific task, packaged as a unit, which\ncan be used in programs wherever that particular task should be performed; the same\nas subprogram, function, method, subroutine, handler.",
    "63\nprogram\ncollection of instructions, written in a given programming language, that can be executed\nby a computer to perform a specific task.",
    "1\nradix\nnumber of unique digits, including the digit zero, used to represent numbers in a posi-\ntional numeral system; the same as base.",
    "25\nradix point\nsign used to separate the integer part of a number from its fractional part in a positional\nnumeral system.",
    "26\nrandom access memory (RAM)\nvolatile computer memory that stores data at a unique address and can recall that data\nupon presentation of the complete unique address.",
    "7\nrange\ndifference between the largest and the smallest representable numbers in a numeral\nsystem.",
    "26\nraster image\ndot matrix data structure that represents a generally rectangular grid of pixels; the same\nas bitmap image.",
    "21\nregister\ntype of computer memory used to quickly access data and instructions used by the CPU;\nthe same as processor register.",
    "6\nrelative jump\nbranch instruction whose possible target is given by an offset relative to the current\nvalue stored in the instruction pointer.",
    "62\nreplacement algorithm\nalgorithm that decides in which cache line to store a new memory block in an associative-\nmapped cache that is full; the same as cache replacement policy.",
    "82\nresource conflict\nsituation in which two instructions in a pipelined CPU require the simultaneous access\nto the same resource.",
    "12\nreturn address\nfield of the stack frame of a given procedure that indicates where to resume execution\nafter the procedure is completed.",
    "64\nGLOSSARY\n108\nsample\nvalue (or set of values) at a point in time of a given signal.",
    "22\nsample resolution\nnumber of bits used to digitally represent the value of each sample.",
    "22\nsampling\nreduction of a continuous-time signal to a discrete-time signal.",
    "22\nsampling rate\nnumber of samples taken per second (measured in Hertz).",
    "23\nscalar variable\nvariable of a scalar type, i.e., one that has no user visible components.",
    "68\nself-modifying code\nprogram that modifies its own instructions during its execution.",
    "8\nset associative mapping\ncache mapping scheme that requires the cache to be divided into sets of associative\nmemory blocks.",
    "80\nside effect\nmodification of the value of some state variable outside the local environment of a pro-\ncedure.",
    "87\nsign\nattribute of a number, indicating if it is either zero, positive, or negative.",
    "37\nsign bit\nbit in a signed number representation that indicates the sign of a number.",
    "30\nsign-magnitude\nsigned number representation that uses a sign bit to indicate the sign of the number and\na set of additional bits to indicate its magnitude. 31\nspatial locality\ntendency of a processor to access the memory locations located near the recently ac-\ncessed ones over a short period of time, when executing a program.",
    "76\nspecial value\nbit pattern in a floating point numeral systems, with the largest or the smallest exponent,\nthat is used to represent either zero, positive or negative infinities, or values that are not\nrepresentable as real numbers.",
    "39\nstack\ndata structure optimised for processing the data elements according to the last-in first-\nout (LIFO) principle.",
    "54\nstack frame\ndata structure in the stack that stores the information needed by a single execution of a\nprocedure; the same as activation record.",
    "64\nstored program computer\ncomputer that stores the programs (and the data) in its internal memory to execute them;\nthe same as general-purpose computer.",
    "8\nstride\nnumber of locations in memory between successive array elements, measured in bytes\nor in units of the size of the array’s elements.",
    "95\n109\nGLOSSARY\nstructured variable\nvariable composed of a set of scalar variables and other structured variables.",
    "68\nsubnormal number\nnon-zero floating-point number with magnitude smaller than the smallest positive nor-\nmal number; the same as denormalised number.",
    "38\nsystem bus\ninternal bus commonly found on a computer that connects the CPU, the main memory,\nand all other internal parts.",
    "4\ntag\ngroup of bits that permits identifying the memory address of the block stored in a given\ncache line.",
    "77\ntemporal locality\ntendency of a processor to access the same memory location several times over a short\nperiod of time, when executing a program.",
    "76\nthroughput\nnumber of instructions completed per unit time.",
    "11\nTuring machine\nmathematical model of a simple computer used to analyse the logical foundations of\ncomputer systems.",
    "8\ntwo’s complement\ncomplement of a n -bit number with respect to 2 n .",
    "32\ntwo’s complement numeral system\nnumeral system in which a negative number is represented by the inverse of the binary\nrepresentations of its corresponding positive number plus one.",
    "32\nunderflow\nsituation that occurs when the value of a number is smaller (that is, closer to zero) than\nthe smallest value representable in the floating point numeral system.",
    "39\nUnicode\ninformation technology standard for the consistent encoding, representation, and han-\ndling of text expressed in most of the world’s writing systems.",
    "18\nvalid bit\nbit in a cache line that indicates whether the data stored in that line is valid or not.",
    "77\nvector image\ncomputer image defined in terms of points on a Cartesian plane, connected by lines and\ncurves to form polygons and other shapes.",
    "22\nvon Neumann architecture\nstored-program machine architecture composed of a CPU, an ALU, registers, and main\n[HEADER] memory.",
    "4.\n\nword\n[HEADER] basic unit of data handled by a given family of computers.",
    "17.",
    "[HEADER] References.",
    "Aho, A. V., Sethi, R., and Ullman, J. D. (1986).",
    "Compilers, principles, techniques, and tools .",
    "Addison-Wesley.",
    "Blum, R. (2005).",
    "Professional assembly language .",
    "Wiley Publishing, Indianapolis, IN, USA.\nBorda, M. (2011).",
    "Fundamentals in information theory and coding .",
    "Springer, Berlin, Germany.",
    "Bryant, R. E. and O’Hallaron, D. R. (2011).",
    "Computer systems: A programmer’s perspective .",
    "Pearson Education, Boston, MA, USA, 2nd edition.",
    "Bryant, R. E. and O’Hallaron, D. R. (2016).",
    "Computer systems: A programmer’s perspective .",
    "Pearson Education, Boston, MA, USA, 3rd edition.",
    "Ceruzzi, P. E. (1998).",
    "A history of modern computing .",
    "MIT Press, Cambridge, MA, USA, 2nd\nedition.",
    "Fenwick, P. (2015).",
    "Introduction to computer data representation .",
    "Bentham Science Publishers,\nSharjah, U.A.E.\nGajski, D. D. (1997).",
    "Principles of digital design .",
    "Prentice-Hall, Upper Saddle River, NJ, USA.\nGoldberg, D. (1991).",
    "What every computer scientist should know about floating-point arith-\nmetic.",
    "ACM Computing Surveys , 23(1):5–48.",
    "DOI 10.1145/103162.103163 .",
    "Harel, D. (2000).",
    "Computers Ltd.: What they really can’t do .",
    "Oxford University Press, Oxford,\nUnited Kingdom.",
    "Hennessy, J. L. and Patterson, D. A. (2007).",
    "Computer architecture: A quantitative approach .",
    "Morgan Kaufmann, San Francisco, CA, USA, 4th edition.",
    "Hennessy, J. L. and Patterson, D. A. (2017).",
    "Computer architecture: A quantitative approach .",
    "Morgan Kaufmann, San Francisco, CA, USA, 6th edition.",
    "Jacob, B., Ng, S. W., and Wang, D. T. (2008).",
    "Memory systems: Cache, DRAM, disk .",
    "Morgan\nKaufmann, Burlington, MA, USA.\nKatz, R. H. (1994).",
    "Contemporary logic design .",
    "Benjamin/Cummings, Redwood City, CA, USA.\nKneusel, R. T. (2017).",
    "Numbers and computers .",
    "Springer, Cham, Switzerland, 2nd edition.",
    "DOI 10.1007/978-3-319-50508-4 .",
    "Knuth, D. E. (1997).",
    "The art of computer programming, volume 2: Seminumerical algorithms .",
    "Addison-Wesley, Boston, MA, USA, 3rd edition.",
    "McEliece, R. (2005).",
    "The theory of information and coding .",
    "Cambridge University Press, 2nd\nedition.",
    "111\nREFERENCES\n112\nNull, L. and Lobur, J. (2003).",
    "The essentials of computer organization and architecture .",
    "Jones\nand Bartlett Publishers, Sudbury, MA, USA.\nPatterson, D. A. and Hennessy, J. L. (2014).",
    "Computer organization and design: The hardware\nsoftware interface .",
    "Morgan Kaufmann, Waltham, MA, USA, 5th edition.",
    "Rojas, R. and Hashagen, U., editors (2000).",
    "The first computers: History and architectures .",
    "MIT\nPress, Cambridge, MA, USA.",
    "Smith, A. J. (1982).",
    "Cache memories.",
    "ACM Computing Surveys , 14(3):473–530.",
    "DOI\n10.1145/356887.356892 .",
    "Stallings, W. (2019).",
    "Computer organization and architecture: Designing for performance .",
    "Pear-\nson Education, New York, NY, USA, 11th edition.",
    "Tanenbaum, A. S. and Austin, T. (2013).",
    "Structured computer organization .",
    "Prentice-Hall,\nUpper Saddle River, NJ, USA, 6th edition.",
    "Unicode Consortium (2007).",
    "The Unicode Standard, Version 5.0 .",
    "Addison-Wesley, 2nd edition.",
    "Wakerly, J. (2001).",
    "Digital design: Principles and practices .",
    "Prentice-Hall, Upper Saddle River,\nNJ, USA, 3rd edition.",
    "[HEADER] Index.\n\nabsolute jump, 62\naddition, 34\naddress, 7 , 17 , 77\naddressing modes, 52\nanalog system, 15\narithmetic logic unit (ALU), 3 , 6\nASCII, 18\nassembler, 3\nassembly phase, 49\nbias, 33\nbig-endian, 8\nbinary, 15\nbinary point, 26\nbinary-coded decimal (BCD), 41\nbit, 16\nBoolean algebra, 16 , 24\nbranch instruction, 12\nbus, 5 , 10\nbyte, 17\ncache, 8 , 95\ncache block, 77\ncache hit, 76\ncache line, 77\ncache memory, 75\ncache miss, 76\ncalculator, 1 , 59\ncallee-saved register, 65\ncaller-saved register, 65\ncell, 7\ncentral processing unit (CPU), 5\nclock, 6\nclock cycle, 6\ncode optimisation, 85\ncolour depth, 22\ncompilation phase, 49",
    "[HEADER] computer, 1 , 1 , 4 , 59.",
    "condition code, 59\ncontent-addressable memory (CAM), 78\n[HEADER] control unit, 6.\n\ndata dependency, 12\ndata path, 3\ndecimal point, 26\ndevice driver, 10\ndigit, 25\ndigital abstraction, 16\ndigital image, 21\ndigital system, 15\ndirect mapping, 78 , 82\ndots per inch (dpi), 22\n[HEADER] dynamic random access memory (DRAM), 7.\n\nend carry-around, 32\nexcess-b representation,",
    "33\n[HEADER] exponent, 37.\n\nfetch-decode-execute cycle, 6\nfixed-point-number, 36\nflip-flop, 3\nfloating-point-number, 36\nfully-associative mapping, 80",
    "[HEADER] gate, 3.\n\nhexadecimal numeral system, 27\nhigh-level language, 2\nhit rate, 76\n[HEADER] hit time, 76.",
    "I/O device, 9\nIEEE 754 floating-point standard, 40\nimage metadata, 21\nimage resolution, 22\ninformation theory, 24\n113\nINDEX\n114\ninline expansion, 93\ninstruction, 1 , 20\ninstruction pointer (IP), 6 , 10 , 51 , 63 , 64\ninstruction register (IR), 6\ninstruction set architecture, 3\ninterrupt, 10\nlabel, 61 , 68\nlatency, 11\nleast significant bit (LSB), 27\nleast significant digit (LSD), 27\nline size, 77\nlinking phase, 49\nlittle-endian, 8\nloader, 49\nloop unrolling, 91\nmachine language, 2\nmagnitude, 31\nmain memory, 7 , 8 , 17 , 75\nmantissa, 38\nmean access time, 78\nmemory, 17\nmemory aliasing, 87\nmicroprogram, 3 , 6\nmiss penalty, 76\nmiss rate, 76\nmost significant bit (MSB), 27\nmost significant digit (MSD), 27\nnatural number, 26\nnibble, 17\nnon-functional requirement, 85\nnormal number, 37\nnot a number (NaN), 39\nnumeral system, 25\noctal numeral system, 27\none’s-complement, 32\none’s-complement numeral system, 31\nopcode, 20\noperating system, 3\noptimisation blocker, 86\noverflow, 33\npipelining, 10\npixel, 21\npolling, 10\npositional numeral system, 25\npreprocessing phase, 48\nprinciple of locality, 76 , 95\nprocedure, 63\nprogram, 1\nradix, 25\nradix point, 26 , 36\nrandom-access memory (RAM), 7\nrange, 26\nraster image, 21\nregister, 3 , 6 , 8 , 50 , 52\nrelative jump, 62\nreplacement algorithm, 82\nresource conflict, 12\nreturn address, 64\nreturn value, 63 , 65\nsample, 22\nsample resolution, 22\nsampling, 22\nsampling rate, 23\nscalar variable, 68\nself-modifying code, 8\nset-associative mapping, 80\nside effect, 87\nsign, 37\nsign bit, 30\nsign-magnitude, 31\nsoftware application, 2\nsound, 22\nspatial locality, 76 , 95\nspecial value, 38 , 39\nstack, 54 , 63\nstack frame, 64\nstatus register, 6\nstored-program computer, 4 , 8\nstride, 95\nstructured variable, 1 , 68\nsubnormal number, 38 , 38\nsystem bus, 4\ntag, 77 , 77\ntemporal locality, 76 , 95\nthroughput, 11\nTuring machine, 8\ntwo’s-complement, 32 , 33\n[HEADER] two’s-complement numeral system, 32.\n\nunderflow, 39",
    "[HEADER] Unicode, 18 , 24.\n\nvalid bit, 77\nvector image, 22\n[HEADER] von Neumann architecture, 4 , 8.",
    "[HEADER] word, 17.",
    "Computers were originally invented to solve all sort of mathematical problems.",
    "Nowadays, computers do much more than that and are present in all human\nactivities.",
    "In fact, a computer is a fantastic machine capable of doing the most\namazing tasks, if an appropriate program is provided.",
    "A computer system con-",
    "tains hardware and systems software that work together to run software ap-\nplications.",
    "Interestingly, the underlying concepts that support the construction\nof a computer are relatively stable.",
    "In fact, (almost) all computer systems have\na similar organisation, i.e., their hardware and software components are arran-\nged in hierarchical layers and perform similar functions.",
    "This book was written\nfor programmers and software engineers who want to comprehend how the\ncomponents of a computer work and how they affect the correctness and per-\nformance of their programs."
  ]
}